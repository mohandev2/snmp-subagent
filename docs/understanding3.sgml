<!-- ...................................................................... -->
<!-- $Id$ ................................................ -->
<!-- 
        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->
<chapter>
    <title>C code</title>
    <para>
      Reading this chapter from top to bottom is the best approach. 
    </para>
  <sect1>
      <title>Initializiation process of sub-agent</title>
      <para>
	The sub-agent is initialized by the call
</para>
	<programlisting role="C">
   33	  /* mib code: nit_netSnmpIETFWGTable from netSnmpIETFWGTable.c */
   34	  init_netSnmpIETFWGTable();  
	</programlisting>
	<para>
	from the sub-agent daemon code.  This call in the generated code 
	calls the function which sets up the skeleton of the table. 
	It does <emphasis>not</emphasis> add any actual values in the columns.
	</para>
	<programlisting role="C">
  717	/************************************************************
  718	 *
  719	 * Initialize the netSnmpIETFWGTable table by defining its contents and how it's structured
  720	 */
  721	void
  722	initialize_table_netSnmpIETFWGTable(void)
  723	{
  724	    netsnmp_table_registration_info *table_info;
  725	
  726	    if(my_handler) {
  727	        snmp_log(LOG_ERR, "initialize_table_netSnmpIETFWGTable_handler called again\n");
  728	        return;
  729	    }
  730	
  731	    memset(&amp cb, 0x00, sizeof(cb));
  732	
  733	    /** create the table structure itself */
  734	    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
  735	
  736	    /* if your table is read only, it's easiest to change the
  737	       HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
  738	    my_handler = netsnmp_create_handler_registration("netSnmpIETFWGTable",
  739	                                             netsnmp_table_array_helper_handler,
  740	                                             netSnmpIETFWGTable_oid,
  741	                                             netSnmpIETFWGTable_oid_len,
  742	                                             HANDLER_CAN_RWRITE);
  743	            
  744	    if (!my_handler || !table_info) {
  745	        snmp_log(LOG_ERR, "malloc failed in "
  746	                 "initialize_table_netSnmpIETFWGTable_handler\n");
  747	        return; /** mallocs failed */
  748	    }
  749	
  750	    /***************************************************
  751	     * Setting up the table's definition
  752	     */
  753	    /*
  754	     * TODO: add any external indexes here.
  755	     */
  756	
  757	    /*
  758	     * internal indexes
  759	     */
  760	        /** index: nsIETFWGName */
  761	        netsnmp_table_helper_add_index(table_info, ASN_OCTET_STR);
  762	
  763	    table_info->min_column = netSnmpIETFWGTable_COL_MIN;
  764	    table_info->max_column = netSnmpIETFWGTable_COL_MAX;
  765	
  766	    /***************************************************
  767	     * registering the table with the master agent
  768	     */
  769	    cb.get_value = netSnmpIETFWGTable_get_value;
  770	    cb.container = netsnmp_container_find("netSnmpIETFWGTable_primary:"
  771	                                          "netSnmpIETFWGTable:"
  772	                                          "table_container");
  773	#ifdef netSnmpIETFWGTable_IDX2
  774	    netsnmp_container_add_index(cb.container,
  775	                                netsnmp_container_find("netSnmpIETFWGTable_secondary:"
  776	                                                       "netSnmpIETFWGTable:"
  777	                                                       "table_container"));
  778	    cb.container->next->compare = netSnmpIETFWGTable_cmp;
  779	#endif
  780	#ifdef netSnmpIETFWGTable_SET_HANDLING
  781	    cb.can_set = 1;
  782	#ifdef netSnmpIETFWGTable_ROW_CREATION
  783	    cb.create_row = (UserRowMethod*)netSnmpIETFWGTable_create_row;
  784	#endif
  785	    cb.duplicate_row = (UserRowMethod*)netSnmpIETFWGTable_duplicate_row;
  786	    cb.delete_row = (UserRowMethod*)netSnmpIETFWGTable_delete_row;
  787	    cb.row_copy = (Netsnmp_User_Row_Operation *)netSnmpIETFWGTable_row_copy;
  788	
  789	    cb.can_activate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_activate;
  790	    cb.can_deactivate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_deactivate;
  791	    cb.can_delete = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_delete;
  792	
  793	    cb.set_reserve1 = netSnmpIETFWGTable_set_reserve1;
  794	    cb.set_reserve2 = netSnmpIETFWGTable_set_reserve2;
  795	    cb.set_action = netSnmpIETFWGTable_set_action;
  796	    cb.set_commit = netSnmpIETFWGTable_set_commit;
  797	    cb.set_free = netSnmpIETFWGTable_set_free;
  798	    cb.set_undo = netSnmpIETFWGTable_set_undo;
  799	#endif
  800	    DEBUGMSGTL(("initialize_table_netSnmpIETFWGTable",
  801	                "Registering table netSnmpIETFWGTable "
  802	                "as a table array\n"));
  803	    netsnmp_table_container_register(my_handler, table_info, &amp cb,
  804	                                     cb.container, 1);
  805	}
</programlisting>
	<para>
	The init routines performs a couple of basic steps.
	</para>
	<sect2><title>Handler</title>
<programlisting role="C">
  736       /* if your table is read only, it's easiest to change the
  737          HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
  738       my_handler = netsnmp_create_handler_registration("netSnmpIETFWGTable",
  739                                                netsnmp_table_array_helper_handler,
  740                                                netSnmpIETFWGTable_oid,
  741                                                netSnmpIETFWGTable_oid_len,
  742                                                HANDLER_CAN_RWRITE);
</programlisting>
	    <para>Create a handler which contains the OID of the table,
	whether it can be written to, and which (if any) if the
	NET-SNMP API helper functions to use.
		</para>
<note>
	<para>An OID - Object IDentifier is a an array of <emphasis>longs</emphasis>.
	The <emphasis>netSnmpIETFWGTable_oid</emphasis> is defined as:</para>
<programlisting role="C">
	oid netSnmpIETFWGTable_oid[] = { 1,3,6,1,4,1,8072,2,2,1 };
</programlisting>
</note>
	<note>
	<para>The <emphasis>netsnmp_table_array_helper_handler</emphasis> is one of many
	helper functions available. Consult the manpage - <emphasis>man netsnmp_table</emphasis>
	</para>
	</note>
	<sect2><title>Notify the helper function</title>

<programlisting role="C">
  760           /** index: nsIETFWGName */
  761           netsnmp_table_helper_add_index(table_info, ASN_OCTET_STR);
  762   
  763       table_info->min_column = netSnmpIETFWGTable_COL_MIN;
  764       table_info->max_column = netSnmpIETFWGTable_COL_MAX;
</programlisting>
		<para>Notify the helper how many indexes tuples to have
		and which type they are.
		</para>
	<note>
	<para>The netSnmpIETFWGTable_COL_MIN are defined in the automaticly generated header file.
	</para>
	</note>
	<note>
	<para>The <emphasis>ASN_OCTET_STR </emphasis> and other types are located in
	the net-snmp/library/asn1.h</para>
	</note>
	</sect2>
	<sect2>
		<title>Register the GET operation</title>
<programlisting role="C">
  766       /***************************************************
  767        * registering the table with the master agent
  768        */
  769       cb.get_value = netSnmpIETFWGTable_get_value;
</programlisting>
		<para>
		 Line 769 registers the GET routine which will be responsible
		for provinding the Net-SNMP API with the correct data and value. More on this in later sections.
		</para>
	</sect2>
	<sect2><title>Register compare function</title>
<programlisting role="C">
  773   #ifdef netSnmpIETFWGTable_IDX2
  774       netsnmp_container_add_index(cb.container,
  775                                   netsnmp_container_find("netSnmpIETFWGTable_secondary:"
  776                                                          "netSnmpIETFWGTable:"
  777                                                          "table_container"));
  778       cb.container->next->compare = netSnmpIETFWGTable_cmp;
  779   #endif
</programlisting>

		<para>Register with the main NetSNMP code (by injecting
		the address of a user-written routine in the callback mechanism) 
		the OID compare routine. This
		routine is <emphasis>NOT</emphasis> needed if your table rows
		don't have any external depedency on sort order. 
		</para>
		<note>
			<para>The compare routine is <emphasis>ONLY</emphasis>
			used during removal of rows. Not when rows are added.
			</para>
		</note>
		<para>	
		More on the compare function in the subsequent section.
		</para>
	</sect2>
	<sect2><title>Alternation and creation of row support</title>
	<programlisting role="C">
  782   #ifdef netSnmpIETFWGTable_ROW_CREATION
  783       cb.create_row = (UserRowMethod*)netSnmpIETFWGTable_create_row;
  784   #endif
	</programlisting>
	<para>
	Without this routine being injected in the call-back mechanism,
	no row creation is possible. The row creation process is
	user-agnostic - the sub-agent code using internal routines or the SNMP-user using SET operation can create new rows.
	</para>
	<para>
	However, the SNMP SET operation has to go through a set
	of other routines to determine if it has the valid syntax,
	the right type and length, and other user-defined tests. Those tests are not
	exercised when the sub-agent code uses the internal routines.
	</para>
	<para>
	The process which the NetSNMP API uses to decide if the data is OK 
	is a four state system. The data is writen to a new row or
	an existing one, if it has passed the RESERVE1, RESERVE2, and ACTION
	phase. The ACTION phase does the modification and if anything goes wrong
	the process moves to UNDO phase. Otherwise a COMMIT is perfomed.
	</para>
	<note>
		<para>This two-phase commit system is unique. Many other
		SNMP sub-agent APIs do not implement such technique and
		have only one SET operation which has to take care of 
		checking the type, size, limitation, perform the write, and
		undo if needed.
		</para>
	</note>
	<para>
	The following picture, from the Net-SNMP Tutorial webpage 
	clearly explains the states.
	</para>
	<mediaobject>
        <imageobject>
          <imagedata fileref="images/set-actions.jpg">
        </imageobject>
      </mediaobject>
	<para>And they are are also part of the call-back mechanism. The internals of those
functions is the responsibilty of the user (more on this in later sections):
	</para>
	<programlisting role="C">
  793       cb.set_reserve1 = netSnmpIETFWGTable_set_reserve1;
  794       cb.set_reserve2 = netSnmpIETFWGTable_set_reserve2;
  795       cb.set_action = netSnmpIETFWGTable_set_action;
  796       cb.set_commit = netSnmpIETFWGTable_set_commit;
  797       cb.set_free = netSnmpIETFWGTable_set_free;
  798       cb.set_undo = netSnmpIETFWGTable_set_undo;
	</programlisting>
	</sect2>

	<sect2>
		<title>Miscellaneous</title>
	<para>
	The write operation also needs a couple of  utility functions
	for the RESERVE1 (defined as netSnmpIETFWGTable_set_reserve1), RESERVE2 (defined as netSnmpIETFWGTable_set_reserve2), ACTION (defined as netSnmpIETFWGTable_set_action), COMMIT (defined as netSnmpIETFWGTable_set_commit) and UNDO (defined as .. well you can guess that one) routines.
	They are part of the call-back mechanism and should be defined.
	Usually you don't need to modify them as the mib2c tool
	does a great job of implementing them. The routines in question are:
	</para>
	<programlisting role="C">
  785       cb.duplicate_row = (UserRowMethod*)netSnmpIETFWGTable_duplicate_row;
  786       cb.delete_row = (UserRowMethod*)netSnmpIETFWGTable_delete_row;
  787       cb.row_copy = (Netsnmp_User_Row_Operation *)netSnmpIETFWGTable_row_copy;
  788   
  789       cb.can_activate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_activate;
  790       cb.can_deactivate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_deactivate;
  791       cb.can_delete = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_delete;
	</programlisting>
	</sect2>
	<sect2>
		<title>Registering handler with container</title>
	<para>
		The last thing that must be done is to register
		the handler, table information (how many rows, columns, etc),
		and the call-back mechansim with the <emphasis>container</emphasis>
	</para>
	<para>
		The container is the Net-SNMP part of code that will
		keep our rows in memory. It will take care of sorting it (when
		new rows are added or removed), providing a specific
		row for a GET/SET request (so you don't have to extract from the OID
		the index/column values and find the row by yourself), and more. This container
		mechanism provides a seperation of the sub-agent programmer
		to have to deal with SNMP GET/SET details and concentrate
		on operating the data.
	</para>
	<note>
		<para>Look in <emphasis>net-snmp/library/container.h</emphasis>
		for more details. The macro calls which are defined in there 
		(CONTAINER_FIRST, CONTAINER_GET_SUBSET, etc) will be explained
		in more details in subsequent sections.
		</para>
	</note>

 <sect3>
  <title>Helper functions to handle n-tuple indexes</title>

  <para>
   Usually tables only require one index value (for example the enumeration of
   network driver). But in some cases there is a need for a second index, or third,
   or an index value coded as a string.
  </para>
  <para>
   Since the index values are used in determining the order of rows (imagine that 
   your index value is a string in UNICODE of a foreign language - the ascending
   order might be completly different from ASCII sort order). 
  </para>
  <para>
   Therfore the NetSNMP API provides a method to register a generic compare function which 
   can handle n-many index tuples. This allows the developer to customize
   in which order rows are added or removed. 
  </para>   
 <sect2>
  <title>Generic compare function</title>

	<para>
	The compare function is only used if <emphasis>netSnmpIETFWGTable_IDX2
	</emphasis> is defined. This compare function is used by NetSNMP API
	when rows are being deleted. If this function is not enabled, the
	NetSNMP API will use its own generic compare function - which compares
	index tuples and returns the answer based on ASCII ascending order.
	</para>
	<para>
	It returns an integer less than, equal to, or greater than zero
	if lhs (first argument) is found, respectively, to be less than, to match, 
	or be greater than rhs.
	</para>
	<para>
	The implementation of this function is quite straightforward. You use
	your own method (of figuring out which of passed <emphasis>context</emphasis>
	structures is less, matches or greater.
	</para>
 </sect2>
 <sect2>
   <title>Tree searching function</title>
    	<para>
    	The tree searching function purpose is to find a <emphasis>context</emphasis>
	structure based on the custom arguments (defined by developer). 
	This function is not used by NetSNMP API - it's a helper function for 
	the developer if needed.
	</para>
	<para>
	It returns a matched <emphasis>context</emphasis> structure based on the
	passed in arguments. 
    	</para> 
  </sect2>
 </sect1>
 
 <sect1>
  <title>Creating and Writting (SNMP SET or user) to rows (and columns)</title>

   <para>
     As mentioned in the first section of this chapter, there are three different
     write-states through which a write request to a column or creation of a row must
     pass until it is considered changed. If there is any failure during these
     write-states, it is automaticly free-ed and the request is discarded. If there
     are no problems, the new request will replace the original (if a column is being
     modified).
    </para>
    <para>
     There are also helper functions that are required for this to work, such as
     making a copy of the row (in case the write is unsucessfull), extracting
     the index tuple, creating the index tuple, free-ing the row and checking to
     see if a row can be safely deleted.
    </para>
    <para>
     Most of these functions (and the helper ones) generated by the 'mib2c' tool have all of its
     basic functionality written. However, some of them require special attention.
    </para>
    <para>
     The functions are geared towards using SNMP SET and changing the columns of a row. As such
     their implementation is geared towards such goal, and at first it might be unclear
     how a sub-agent would create a row by itself. This will be explained in details
     at the end of this section.
    </para>
    <para>
     To have a better grasp of how the sub-agent would handle request, it is important to
     first explain some of the helper functions.
    </para>
   <sect2>

    <title>Helper functions</title>

    <para>There are usually three helper functions generated by the 'mib2c' tool.
    They are:
    </para>
     <sect3> <title>Row copy</title>

       <para>
         <emphasis>netSnmpIETFWGTable_row_copy</emphasis>. As the name implies - this
	 function purpose is to copy itself.  The generated implementation takes care
	 of copying all of the <emphasis>context</emphasis> structure records.
	 Of interest might be the function <emphasis>snmp_clone_mem</emphasis> which
	 copies the index tuple based on the length of the oid. The reason why
	 a normal memcpy function is not used is due to the neccessity of error checking.
	 If the function cannot determing the correct length of the index tuple 
	 (for example the index tuple length might be defined as zero) the copying of
	 the row is stopped. Of course having rows with no index values should 
	 never have happend in the first place, but you never known.
	</para>
     </sect3>

     <sect3>
 	<title>Extracting index</title>

	<para>
	 The <emphasis>netSnmpIETFWGTable_extract_index</emphasis> is a very
	important function and needs tweaking to work. It's purpose is
	to generate the index tuple in an appropiate format for NetSNMP API 
	to understand. 
	</para>
	<para>
	 The end result is to create a linked list of index values and store
	 it in <emphasis>netsnmp_index * hdr</emphasis>. 
	</para>
	<para>
	 The snippets of code generated by the 'mib2c' tool mostly do 
	 the work for the developer. However it might be unclear what
	 exactly is being done.
	</para>
	<programlisting role='C'>
197     netsnmp_variable_list var_nsIETFWGName;
...
212     /**
213      * Create variable to hold each component of the index
214      */
215        memset( &amp var_nsIETFWGName, 0x00, sizeof(var_nsIETFWGName) );
216        var_nsIETFWGName.type = ASN_OCTET_STR;
217        /** TODO: link this index to the next, or NULL for the last one */
218 #ifdef TABLE_CONTAINER_TODO
219     snmp_log(LOG_ERR, "netSnmpIETFWGTable_extract_index index list not implemented        !\n" );
220     return 0;
221 #else
222        var_nsIETFWGName.next_variable = &amp var_XX;
223 #endif
224
	</programlisting>
	<para>
	  The <emphasis>var_nsIETFWGName</emphasis> is the first index of 
	the row. If there were more index values they would be defined as well.
	</para>
	<para>In lines 212-224 the linked list of the index values is built.
	Each of the var_&lt;named values&gt; (if there would be more than just one
	index value) type is set and a linked to the next index value.
	</para>
	<para>
	For example, if this table had two extra index values: an enumerated integer
	value (nsIETFWGProgress) and TruthValue (nsIETFWGIsWorking) with the following ASN.1 definition: 
<programlisting role='C'>
nsIETFWGProgress OBJECT-TYPE
    SYNTAX      INTEGER {
			undefined(0),
			proposed(1),
			debated(2),
			rewritting(3),
			draft(4),
			standard(5)					
		}	
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "Progress of a work-group"
    ::= { netSnmpIETFWGEntry 4 }

nsIETFWGIsWorking OBJECT-TYPE
    SYNTAX      TruthValue
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
        "Is the work group still working?"
    ::= { netSnmpIETFWGEntry 5 }
</programlisting>
	<para>
	And netSnmpIETFWGEntry would define these objects as two extra index values:
	</para>
<programlisting role='C'>
  103     INDEX   { nsIETFWGName, nsIETFWGProgress, nsIETFWGIsWorking }
</programlisting>
	<para>
	These two extra ASN.1 entries would add two extra variables in the <emphasis>
	context</emphasis> structure:
	</para>
<programlisting role='C'>
        /** INTEGER = ASN_INTEGER */
    long nsIETFWGProgress;

	/** TruthValue = ASN_INTEGER */
    long nsIETFWGIsWorking;
</programlisting>
	<para>
	As such, the <emphasis>_extract_index</emphasis> code snippet would 
	look like this:
	</para>
<programlisting role='C'>
    netsnmp_variable_list var_nsIETFWGName;
    netsnmp_variable_list var_nsIETFWGProgress;
    netsnmp_variable_list var_nsIETFWGIsWorking;

       memset( &amp var_nsIETFWGName, 0x00, sizeof(var_nsIETFWGName) );
       var_nsIETFWGName.type = ASN_OCTET_STR;
       var_nsIETFWGName.next_variable = &amp var_nsIETFWGProgress;

       memset( &amp var_nsIETFWGProgress, 0x00, sizeof(var_nsIETFWGProgress) );
       var_nsIETFWGProgress.type = ASN_INTEGER;
       var_nsIETFWGProgress.next_variable = &amp var_nsIETFWGIsWorking;

       memset( &amp var_nsIETFWGIsWorking, 0x00, sizeof(var_nsIETFWGIsWorking) );
       var_nsIETFWGIsWorking.type = ASN_OCTET_STR;
       var_nsIETFWGIsWorking.next_variable = NULL;
</programlisting>
     </sect3>
   </sect2>
  </sect1>
</chapter>
