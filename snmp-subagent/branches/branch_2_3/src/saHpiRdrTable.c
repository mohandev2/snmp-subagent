/*
 * (C) Copyright IBM Corp. 2005
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Authors:
 *   David Judkovics  <djudkovi@us.ibm.com>
 *   Daniel de Araujo <ddearauj@us.ibm.com>
 *
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.18.2.2 2004/02/09 18:21:47 rstory Exp $
 *
 * $Id$
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial-5/
 *
 *
 * You can also join the #net-snmp channel on irc.freenode.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 * Yes, there is lots of code here that you might not use. But it is much
 * easier to remove code than to add it!
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include <SaHpi.h>
#include "saHpiRdrTable.h"
#include <hpiSubagent.h>
#include <hpiCheckIndice.h>
#include <saHpiResourceTable.h>
#include <saHpiCtrlDigitalTable.h>
#include <saHpiCtrlDiscreteTable.h>
#include <saHpiCtrlAnalogTable.h>
#include <saHpiCtrlStreamTable.h>
#include <saHpiCtrlTextTable.h>
#include <saHpiCtrlOemTable.h>
#include <saHpiSensorTable.h>
#include <saHpiCurrentSensorStateTable.h>
#include <saHpiInventoryTable.h>
#include <saHpiWatchdogTable.h>
#include <saHpiAnnunciatorTable.h>

#include <session_info.h>

#include <oh_utils.h>
#include <hpiLock.h>


static     netsnmp_handler_registration *my_handler = NULL;
static     netsnmp_table_array_callbacks cb;

oid saHpiRdrTable_oid[] = { saHpiRdrTable_TABLE_OID };
size_t saHpiRdrTable_oid_len = OID_LENGTH(saHpiRdrTable_oid);


/*************************************************************
 *  scalars 
 */
static oid saHpiRdrActiveEntries_oid[] = { 1,3,6,1,4,1,18568,2,1,1,4,1 };
static u_long rdr_entry_count = 0;

/*
 * void populate_saHpiRdrTable(void)
 */
int populate_saHpiRdrTable(SaHpiSessionIdT sessionid, 
			   SaHpiRptEntryT *rpt_entry,
			   oid * resource_oid, 
			   size_t resource_oid_len)
{
	/* 
	 * From   oid * resource_oid, size_t resource_oid_len
	 *       INDEX   { saHpiDomainId, 
	 *		saHpiResourceEntryId,
	 *       	saHpiResourceIsHistorical 
	 *		} 
	 *
	 */

 	SaErrorT 		rv;   
        int                     new_row = MIB_FALSE;

	SaHpiEntryIdT    	rdr_entry_id;
	SaHpiRdrT		rdr_entry;
	oh_big_textbuffer	bigbuf;
		
	oid 			rdr_oid[RDR_INDEX_NR];
	netsnmp_index 		rdr_index;
	saHpiRdrTable_context	*rdr_context;

	oid column[2];
	int column_len = 2;
	oid full_oid[MAX_OID_LEN];
	size_t full_oid_len;
	oid child_oid[MAX_OID_LEN];
	size_t child_oid_len;

	netsnmp_index resource_index;

	DEBUGMSGTL ((AGENT, "populate_saHpiRdrTable, called\n"));

        /*
        remove all matching rows for domainId and resourceId pairs.
        seems have to pass in if this a new rdr or existing to the under lying tables.
        then we can determine

        for every this rdr it should be very simple to vector down into the accompanying 
        underlying table and find and delete    

        If its a RESTORE or ADD we need to Remove all existing RDR's and rediscover..this 
        can also work for rediscovery

        so we need a purge fucntion for all rdr's here and all underlying sub tables based in domian, 
        resource and rdr num values we can use the child RowStatus here to get to sub tables and scan 
        here based on row pointer to Resource in Resource Table

        based on Resoruce above we can build the expected RowPointer value that would be stored here
        and then scan the RDR table here looking for matches.  

        Then when a row is found we can get the RowPointer to the underlying table and jump to it and
        purge that row.  INventory RDR's will require multiple hops.
        */

        
	subagent_lock(&hpi_lock_data);
	
	rv = clear_rdr_container(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_digital(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_discrete(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_analog(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_stream(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_text(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_ctrl_oem(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_sensor(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_current_sensor_state(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_inventory(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_watchdog(resource_oid[0], rpt_entry->ResourceId);
        rv = clear_annunciator(resource_oid[0], rpt_entry->ResourceId);

	rdr_entry_id = SAHPI_FIRST_ENTRY;
	do {
		rv =  saHpiRdrGet(sessionid, 
				  rpt_entry->ResourceId, 
				  rdr_entry_id, 
				  &rdr_entry_id, 
				  &rdr_entry);
	
		if (rv != SA_OK) {
			DEBUGMSGTL ((AGENT, "saHpiRdrGet Failed: rv = %d\n",rv));
			rv =  AGENT_ERR_INTERNAL_ERROR;
			break;
		}

		/* From MIB table index 
		 * INDEX { 
		 *	saHpiDomainId, 
		 *	saHpiResourceId, 
		 *      saHpiResourceIsHistorical,
		 *	saHpiRdrEntryId
		 * }
		 */
		rdr_index.len = RDR_INDEX_NR;
		rdr_oid[0] = resource_oid[0];   
		rdr_oid[1] = rpt_entry->ResourceId;
		rdr_oid[2] = MIB_FALSE;
		rdr_oid[3] = rdr_entry.RecordId;
		rdr_index.oids = (oid *) &rdr_oid;
		
		/* See if it exists. */
		rdr_context = NULL;
		rdr_context = CONTAINER_FIND(cb.container, &rdr_index);
			
		if (!rdr_context) { 
			// New entry. Add it
			rdr_context = 
				saHpiRdrTable_create_row(&rdr_index);
                        new_row = MIB_TRUE;
		} 
		if (!rdr_context) {
			snmp_log (LOG_ERR, "Not enough memory for a Rdr row!");
			rv = AGENT_ERR_INTERNAL_ERROR;
			break;
		} 

		/*
		 * Build the full oid for THIS rdr, then pass it to
		 * the appropriate populate() for its RowPointer. Then accept 
		 * its full oid to use in this rdr's RowPointer.
		 */
		column[0] = 1;
		column[1] = COLUMN_SAHPIRDRENTRYID;
		memset(full_oid, 0, MAX_OID_LEN);
		build_full_oid (saHpiRdrTable_oid, saHpiRdrTable_oid_len,
				column, column_len,
				&rdr_index,
				full_oid, MAX_OID_LEN, &full_oid_len);
		/*
		 * make sure we don't pickup previous rdr type's oid  
		 * this shall be the oid of the corresponding rdr type's 
		 * table
		 */
		memset(&child_oid, 0, MAX_OID_LEN);
		child_oid_len = 0;

		/*
		 * call the _populate() fpr the corresponding 'type'
		 * specific table.
		 */
		switch (rdr_entry.RdrType) {
		case SAHPI_NO_RECORD:
			DEBUGMSGTL((AGENT, "SAHPI_NO_RECORD: ERROR STATE\n"));
			break;

		case SAHPI_CTRL_RDR:
			DEBUGMSGTL ((AGENT,
				     "SAHPI_CTRL_RDR; RPT: %d, RDR: %d, CtrlRec.Num: %d\n",
				      rpt_entry->ResourceId,
				      rdr_entry.RecordId,
				      rdr_entry.RdrTypeUnion.CtrlRec.Num));
			switch (rdr_entry.RdrTypeUnion.CtrlRec.Type) {
			case SAHPI_CTRL_TYPE_DIGITAL:
				rv = populate_ctrl_digital(sessionid,
							   &rdr_entry,
							   rpt_entry,
							   full_oid, full_oid_len,
							   child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_digital rv: %s\n",
					    oh_lookup_error(rv)));
 				break;
			case SAHPI_CTRL_TYPE_DISCRETE:
				rv = populate_ctrl_discrete(sessionid,
							    &rdr_entry,
							    rpt_entry,
							    full_oid, full_oid_len,
							    child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_discrete rv: %s\n",
					    oh_lookup_error(rv)));            
				break;
			case SAHPI_CTRL_TYPE_ANALOG:
				rv = populate_ctrl_analog(sessionid,
							  &rdr_entry,
							  rpt_entry,
							  full_oid, full_oid_len,
							  child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_analog rv: %s\n",
					    oh_lookup_error(rv))); 
				break;
			case SAHPI_CTRL_TYPE_STREAM:
				rv = populate_ctrl_stream(sessionid,
							  &rdr_entry,
							  rpt_entry,
							  full_oid, full_oid_len,
							  child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_stream rv: %s\n",
					    oh_lookup_error(rv))); 
				break;
			case SAHPI_CTRL_TYPE_TEXT:
				rv = populate_ctrl_text(sessionid,
							&rdr_entry,
							rpt_entry,
							full_oid, full_oid_len,
							child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_text rv: %s\n",
					    oh_lookup_error(rv))); 
				break;

		       case SAHPI_CTRL_TYPE_OEM:
				rv = populate_ctrl_oem(sessionid,
						       &rdr_entry,
						       rpt_entry,
						       full_oid, full_oid_len,
						       child_oid, &child_oid_len);
				DEBUGMSGTL((AGENT,
					    "populate_ctrl_oem rv: %s\n",
					    oh_lookup_error(rv)));
				break;
			default:
				DEBUGMSGTL ((AGENT, 
		                "SAHPI_CTRL_RDR UNKNOWN TYPE: Not implemented\n"));
				break;
			}
			break;

		case SAHPI_SENSOR_RDR:
			DEBUGMSGTL ((AGENT,
				     "SAHPI_SENSOR_RDR; RPT: %d, RDR: %d, SensorRec.Num: %d\n",
				      rpt_entry->ResourceId,
				      rdr_entry.RecordId,
				      rdr_entry.RdrTypeUnion.SensorRec.Num));

			/* saHpiSensorTable */
			rv = populate_sensor (sessionid,
					      &rdr_entry,
					      rpt_entry,
					      full_oid, full_oid_len,
					      child_oid, &child_oid_len);
			DEBUGMSGTL((AGENT, 
		        "Called populate_sensor(); rc: %d\n",rv));

			/* saHpiCurrentSensorStateTable */
			rv = populate_current_sensor_state (sessionid,
							    &rdr_entry,
							    rpt_entry,
							    full_oid, full_oid_len);
			DEBUGMSGTL((AGENT, 
		       "Called populate_current_sensor_state(); rc: %d\n", rv));

			break;

		case SAHPI_INVENTORY_RDR:
			DEBUGMSGTL ((AGENT,
				      "SAHPI_INVENTORY_RDR; RPT: %d, RDR: %d, InventoryRec.IdrId: %d\n",
				      rpt_entry->ResourceId,
				      rdr_entry.RecordId,
				      rdr_entry.RdrTypeUnion.InventoryRec.IdrId));
			rv = populate_inventory (sessionid,
                                                 &rdr_entry,
                                                 rpt_entry,
                                                 full_oid, full_oid_len,
                                                 child_oid, &child_oid_len);
			DEBUGMSGTL ((AGENT,
				     "Called populate_inventory(); rc: %d\n",
				     rv));
			break;

		case SAHPI_WATCHDOG_RDR:
			DEBUGMSGTL ((AGENT,
				      "SAHPI_WATCHDOG_RDR; RPT: %d, RDR: %d, WatchdogRec.WatchdogNum: %d\n",
				      rpt_entry->ResourceId,
				      rdr_entry.RecordId,
				      rdr_entry.RdrTypeUnion.WatchdogRec.WatchdogNum));
			rv = populate_watchdog (sessionid,
					        &rdr_entry,
					        rpt_entry,
					        full_oid, full_oid_len,
					        child_oid, &child_oid_len);
			DEBUGMSGTL ((AGENT,
				     "Called populate_watchdog(); rc: %d\n",
				     rv));
			break;

		case SAHPI_ANNUNCIATOR_RDR:
			DEBUGMSGTL ((AGENT,
				      "SAHPI_ANNUNCIATOR_RDR; RPT: %d, RDR: %d, AnnunciatorRec.AnnunciatorNum: %d\n",
				      rpt_entry->ResourceId,
				      rdr_entry.RecordId,
				      rdr_entry.RdrTypeUnion.AnnunciatorRec.AnnunciatorNum));
			rv = populate_annunciator (sessionid,
                                                   &rdr_entry,
                                                   rpt_entry,
                                                   full_oid, full_oid_len,
                                                   child_oid, &child_oid_len);
			DEBUGMSGTL ((AGENT,
				     "Called populate_annunciator(); rc: %d\n",
				     rv));

			break;

		default:
			DEBUGMSGTL((AGENT, "RdrType,default: Not Implemented\n"));
			break;
		}


		/** COUNTER = ASN_COUNTER */
		rdr_context->saHpiRdrEntryId = rdr_entry.RecordId;
	
		/** COUNTER = ASN_COUNTER */
                rdr_context->saHpiRdrNextEntryId = rdr_entry_id;
	
		/** INTEGER = ASN_INTEGER */
		rdr_context->saHpiRdrType = rdr_entry.RdrType + 1;
	
		/** SaHpiEntityPath = ASN_OCTET_STR */
		memset(rdr_context->saHpiRdrEntityPath,
		       0, sizeof(oh_big_textbuffer));
		
		memset(&bigbuf, 0, sizeof(oh_big_textbuffer));        
		
		rv = oh_decode_entitypath(&rdr_entry.Entity, &bigbuf);
		
		if (rv != SA_OK) {
			DEBUGMSGTL ((AGENT, 
			"ERROR: RDR, oh_decode_entitypath() rv = %d\n",rv));
			rv =  AGENT_ERR_INTERNAL_ERROR;
			saHpiRdrTable_delete_row(rdr_context);
			break;
		}       
			 
		memcpy(rdr_context->saHpiRdrEntityPath,
		       bigbuf.Data, bigbuf.DataLength );
		
		
		if ((bigbuf.Data[bigbuf.DataLength - 1] == 0x00) && 
			(bigbuf.DataType == SAHPI_TL_TYPE_TEXT))         		
			rdr_context->saHpiRdrEntityPath_len = 
				bigbuf.DataLength - 1;
		else
			rdr_context->saHpiRdrEntityPath_len = 
				bigbuf.DataLength;
	
		/** TruthValue = ASN_INTEGER */
		rdr_context->saHpiRdrIsFru = 
			(rdr_entry.IsFru == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;
	
		/** RowPointer = ASN_OBJECT_ID */ 
		memset(rdr_context->saHpiRdrRowPointer, 
		       0, sizeof(rdr_context->saHpiRdrRowPointer));

		rdr_context->saHpiRdrRowPointer_len = 
			child_oid_len * sizeof(oid);

		memcpy(rdr_context->saHpiRdrRowPointer, 
		       child_oid, 
		       rdr_context->saHpiRdrRowPointer_len);

	
		/** RowPointer = ASN_OBJECT_ID */
		column[0] = 1;
		column[1] = COLUMN_SAHPIRESOURCEID;
		resource_index.len = resource_oid_len;
		resource_index.oids = resource_oid;
		memset(full_oid, 0, MAX_OID_LEN);

		build_full_oid (saHpiResourceTable_oid, saHpiResourceTable_oid_len,
				column, column_len,
				&resource_index,
				full_oid, MAX_OID_LEN, &full_oid_len);

		rdr_context->saHpiRdrRPT_len = full_oid_len * sizeof (oid);
		memcpy (rdr_context->saHpiRdrRPT, 
			full_oid, 
			rdr_context->saHpiRdrRPT_len);

		/** SaHpiTextType = ASN_INTEGER */
		rdr_context->saHpiRdrTextType = 
			rdr_entry.IdString.DataType + 1;
	
		/** SaHpiTextLanguage = ASN_INTEGER */
		rdr_context->saHpiRdrTextLanguage = 
			rdr_entry.IdString.Language + 1;
	
		/** OCTETSTR = ASN_OCTET_STR */
		memset(rdr_context->saHpiRdrIdString, 
		       0, SAHPI_MAX_TEXT_BUFFER_LENGTH);
		memcpy(rdr_context->saHpiRdrIdString, 
		       rdr_entry.IdString.Data, 
		       rdr_entry.IdString.DataLength);        		
        		
		if ((rdr_entry.IdString.Data[rdr_entry.IdString.DataLength - 1] == 0x00) 
			&& (rdr_entry.IdString.DataType == SAHPI_TL_TYPE_TEXT))         		
			rdr_context->saHpiRdrIdString_len = 
				rdr_entry.IdString.DataLength - 1;
		else
			rdr_context->saHpiRdrIdString_len = 
				rdr_entry.IdString.DataLength;  

                if (new_row == MIB_TRUE) 
                        CONTAINER_INSERT (cb.container, rdr_context);
	
	} while (rdr_entry_id !=  SAHPI_LAST_ENTRY );
	
	rdr_entry_count = CONTAINER_SIZE (cb.container);
	
	DEBUGMSGTL ((AGENT, "populate_saHpiRdrTable: rdr_entry_count = %d\n", rdr_entry_count));
		
	
	subagent_unlock(&hpi_lock_data);
	return rv;

} 


/**
 * 
 * @domainId
 * @resourceId
 * 
 * @return 
 */
SaErrorT clear_rdr_container(SaHpiDomainIdT domainId, 
                             SaHpiResourceIdT resourceId)

{
        SaErrorT rv = SA_OK;
        netsnmp_index *row_idx;
        saHpiRdrTable_context *rdr_ctx;

        int counter = 1;

	DEBUGMSGTL ((AGENT, "clear_rdr_container, called\n"));	
	DEBUGMSGTL ((AGENT, "           domainId   [%d]\n", domainId));	
	DEBUGMSGTL ((AGENT, "           resourceId [%d]\n", resourceId));	

        row_idx = CONTAINER_FIRST(cb.container);
        if (row_idx) //At least one entry was found.
        {
                do {
                        rdr_ctx = CONTAINER_FIND(cb.container, row_idx);
                        
                        DEBUGMSGTL ((AGENT, "CONTAINER_FIND: rdr_ctx: [%d] row_idx: [%d]"
                                            " counter [%d], rdr_entry_count [%d]\n", 
                                     rdr_ctx, row_idx, counter++, rdr_entry_count));

                        row_idx = CONTAINER_NEXT(cb.container, row_idx);

                        if ((rdr_ctx->index.oids[saHpiRdrDomainId_Index] ==
                             domainId) &&

                            (rdr_ctx->index.oids[saHpiRdrResourceId_Index] ==
                             resourceId)) {

                                /* all conditions met remove row */
                                CONTAINER_REMOVE (cb.container, rdr_ctx);
                                saHpiRdrTable_delete_row (rdr_ctx);
                                rdr_entry_count = CONTAINER_SIZE (cb.container);
                                DEBUGMSGTL ((AGENT, "clear_rdr_container: found row: removing\n"));

                        }

                } while (row_idx);
        } 

        return rv;
}


/*
 * int handle_saHpiRdrActiveEntries()
 */
int
handle_saHpiRdrActiveEntries(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	DEBUGMSGTL ((AGENT, "handle_saHpiRdrActiveEntries, called\n"));	

    rdr_entry_count = CONTAINER_SIZE (cb.container);
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
                                     (u_char *) &rdr_entry_count,
				     sizeof(rdr_entry_count));
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * int initialize_table_saHpiResourceActiveEntries()
 */
int initialize_table_saHpiRdrActiveEntries(void)
{
	DEBUGMSGTL ((AGENT, "initialize_table_saHpiRdrActiveEntries, called\n"));	

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"saHpiRdrActiveEntries", 
			handle_saHpiRdrActiveEntries,
                        saHpiRdrActiveEntries_oid, 
			OID_LENGTH(saHpiRdrActiveEntries_oid),
                        HANDLER_CAN_RONLY ));
	return 0;
}


/************************************************************/
/************************************************************/
/************************************************************/
/************************************************************/


/************************************************************
 * keep binary tree to find context by name
 */
static int saHpiRdrTable_cmp( const void *lhs, const void *rhs );

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
static int
saHpiRdrTable_cmp( const void *lhs, const void *rhs )
{
	saHpiRdrTable_context *context_l =
	    (saHpiRdrTable_context *)lhs;
	saHpiRdrTable_context *context_r =
	    (saHpiRdrTable_context *)rhs;
	
	/*
	 * check primary key, then secondary. Add your own code if
	 * there are more than 2 indexes
	 */

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_cmp, called\n"));

	/* check for NULL pointers */
	if(lhs == NULL || rhs == NULL ) {
	    DEBUGMSGTL((AGENT,"saHpiRdrTable_cmp() NULL pointer ERROR\n" ));
		return 0;
	}	
	/* CHECK FIRST INDEX,  saHpiDomainId */
	if ( context_l->index.oids[0] < context_r->index.oids[0])
	    return -1;
		
	if ( context_l->index.oids[0] > context_r->index.oids[0])
	    return 1;			         
	       
	if ( context_l->index.oids[0] == context_r->index.oids[0]) {
	       /* If saHpiDomainId index is equal sort by second index */
	       /* CHECK SECOND INDEX,  saHpiResourceEntryId */
	       if ( context_l->index.oids[1] < context_r->index.oids[1])
		  return -1;
		
	       if ( context_l->index.oids[1] > context_r->index.oids[1])
		  return 1;			
		      
	        if ( context_l->index.oids[1] == context_r->index.oids[1]) {
		/* If saHpiResourceEntryId index is equal sort by third index */
		/* CHECK THIRD INDEX,  saHpiResourceIsHistorical */
			if ( context_l->index.oids[2] < context_r->index.oids[2])
			     return -1;
				
			if ( context_l->index.oids[2] > context_r->index.oids[2])
			     return 1;
					
			if ( context_l->index.oids[2] == context_r->index.oids[2]) {
				/* If saHpiResourceIsHistorical index is equal sort by forth index */
				/* CHECK FORTH INDEX,  saHpiRdrEntryId */
				if ( context_l->index.oids[3] < context_r->index.oids[3])
				     return -1;
					
				if ( context_l->index.oids[3] > context_r->index.oids[3])
				     return 1;
						
				if ( context_l->index.oids[3] == context_r->index.oids[3])
				     return 0;
			}
		}
	}
	return 0;
}

/************************************************************
 * Initializes the saHpiRdrTable module
 */
void
init_saHpiRdrTable(void)
{

	DEBUGMSGTL ((AGENT, "init_saHpiRdrTable, called\n"));
	
	initialize_table_saHpiRdrTable();
	
	initialize_table_saHpiRdrActiveEntries();

}

/************************************************************
 * the *_row_copy routine
 */
static int saHpiRdrTable_row_copy(saHpiRdrTable_context * dst,
                         saHpiRdrTable_context * src)
{

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_row_copy, called\n"));
	
	if(!dst||!src)
	    return 1;
	    
        subagent_lock(&hpi_lock_data);

	/*
	 * copy index, if provided
	 */
	if(dst->index.oids)
	    free(dst->index.oids);
	if(snmp_clone_mem( (void*)&dst->index.oids, src->index.oids,
			       src->index.len * sizeof(oid) )) {
	    dst->index.oids = NULL;
            subagent_unlock(&hpi_lock_data);
	    return 1;
	}
	dst->index.len = src->index.len;
	
	
	/*
	 * copy components into the context structure
	 */
	/** TODO: add code for external index(s)! */
	dst->saHpiRdrEntryId = src->saHpiRdrEntryId;
	
	dst->saHpiRdrNextEntryId = src->saHpiRdrNextEntryId;
	
	dst->saHpiRdrType = src->saHpiRdrType;
	
	memcpy( dst->saHpiRdrEntityPath, src->saHpiRdrEntityPath, src->saHpiRdrEntityPath_len );
	dst->saHpiRdrEntityPath_len = src->saHpiRdrEntityPath_len;
	
	dst->saHpiRdrIsFru = src->saHpiRdrIsFru;
	
	memcpy( dst->saHpiRdrRowPointer, src->saHpiRdrRowPointer, src->saHpiRdrRowPointer_len );
	dst->saHpiRdrRowPointer_len = src->saHpiRdrRowPointer_len;
	
	memcpy( dst->saHpiRdrRPT, src->saHpiRdrRPT, src->saHpiRdrRPT_len );
	dst->saHpiRdrRPT_len = src->saHpiRdrRPT_len;
	
	dst->saHpiRdrTextType = src->saHpiRdrTextType;
	
	dst->saHpiRdrTextLanguage = src->saHpiRdrTextLanguage;
	
	memcpy( dst->saHpiRdrIdString, src->saHpiRdrIdString, src->saHpiRdrIdString_len );
	dst->saHpiRdrIdString_len = src->saHpiRdrIdString_len;
	
        subagent_unlock(&hpi_lock_data);
	return 0;
}
/**
 * the *_extract_index routine
 *
 * This routine is called when a set request is received for an index
 * that was not found in the table container. Here, we parse the oid
 * in the the individual index components and copy those indexes to the
 * context. Then we make sure the indexes for the new row are valid.
 */
int
saHpiRdrTable_extract_index( saHpiRdrTable_context * ctx, netsnmp_index * hdr )
{
	DEBUGMSGTL ((AGENT, "saHpiRdrTable_extract_index, called\n"));
        subagent_lock(&hpi_lock_data);
	
	/*
	 * temporary local storage for extracting oid index
	 *
	 * extract index uses varbinds (netsnmp_variable_list) to parse
	 * the index OID into the individual components for each index part.
	 */
	/** TODO: add storage for external index(s)! */
	netsnmp_variable_list var_saHpiDomainId;
	netsnmp_variable_list var_saHpiResourceId;
	netsnmp_variable_list var_saHpiResourceIsHistorical;
	netsnmp_variable_list var_saHpiRdrEntryId;
	int err;
	
	/*
	 * copy index, if provided
	 */
	if(hdr) {
	    netsnmp_assert(ctx->index.oids == NULL);
	    if(snmp_clone_mem( (void*)&ctx->index.oids, hdr->oids,
			       hdr->len * sizeof(oid) )) {
                    subagent_unlock(&hpi_lock_data);
		    return -1;
	    }
	    ctx->index.len = hdr->len;
	}
	
	/*
	 * initialize variable that will hold each component of the index.
	 * If there are multiple indexes for the table, the variable_lists
	 * need to be linked together, in order.
	 */
	   /** TODO: add code for external index(s)! */
	   memset( &var_saHpiDomainId, 0x00, sizeof(var_saHpiDomainId) );
	   var_saHpiDomainId.type = ASN_UNSIGNED; /* type hint for parse_oid_indexes */
	   /** TODO: link this index to the next, or NULL for the last one */
	   var_saHpiDomainId.next_variable = &var_saHpiResourceId;
	
	   memset( &var_saHpiResourceId, 0x00, sizeof(var_saHpiResourceId) );
	   var_saHpiResourceId.type = ASN_UNSIGNED; /* type hint for parse_oid_indexes */
	   /** TODO: link this index to the next, or NULL for the last one */
	   var_saHpiResourceId.next_variable = &var_saHpiResourceIsHistorical;
	
	   memset( &var_saHpiResourceIsHistorical, 0x00, sizeof(var_saHpiResourceIsHistorical) );
	   var_saHpiResourceIsHistorical.type = ASN_INTEGER; /* type hint for parse_oid_indexes */
	   /** TODO: link this index to the next, or NULL for the last one */
	   var_saHpiResourceIsHistorical.next_variable = &var_saHpiRdrEntryId;
	
	   memset( &var_saHpiRdrEntryId, 0x00, sizeof(var_saHpiRdrEntryId) );
	   var_saHpiRdrEntryId.type = ASN_COUNTER; /* type hint for parse_oid_indexes */
	   /** TODO: link this index to the next, or NULL for the last one */
	   var_saHpiRdrEntryId.next_variable = NULL;
	
	/*
	 * parse the oid into the individual index components
	 */
	err = parse_oid_indexes( hdr->oids, hdr->len, &var_saHpiDomainId );
	if (err == SNMP_ERR_NOERROR) {
	    /*
	     * copy index components into the context structure
	     */
		/** skipping external index saHpiDomainId */
	
		/** skipping external index saHpiResourceId */
	
		/** skipping external index saHpiResourceIsHistorical */
	
		ctx->saHpiRdrEntryId = *var_saHpiRdrEntryId.val.integer;
	
		err = saHpiDomainId_check_index(*var_saHpiDomainId.val.integer);
		err = saHpiResourceEntryId_check_index(*var_saHpiResourceId.val.integer);  
		err = saHpiResourceIsHistorical_check_index(*var_saHpiResourceIsHistorical.val.integer);
		err = saHpiRdrEntryId_check_index(*var_saHpiRdrEntryId.val.integer);
	
	}
	
	/*
	 * parsing may have allocated memory. free it.
	 */
	snmp_reset_var_buffers( &var_saHpiDomainId );

        subagent_unlock(&hpi_lock_data);
	return err;
}

/************************************************************
 * the *_can_activate routine is called
 * when a row is changed to determine if all the values
 * set are consistent with the row's rules for a row status
 * of ACTIVE.
 *
 * return 1 if the row could be ACTIVE
 * return 0 if the row is not ready for the ACTIVE state
 */
int saHpiRdrTable_can_activate(saHpiRdrTable_context *undo_ctx,
                      saHpiRdrTable_context *row_ctx,
                      netsnmp_request_group * rg)
{

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_can_activate, called\n"));

    /*
     * TODO: check for activation requirements here
     */


    /*
     * be optimistic.
     */
    return 1;
}

/************************************************************
 * the *_can_deactivate routine is called when a row that is
 * currently ACTIVE is set to a state other than ACTIVE. If
 * there are conditions in which a row should not be allowed
 * to transition out of the ACTIVE state (such as the row being
 * referred to by another row or table), check for them here.
 *
 * return 1 if the row can be set to a non-ACTIVE state
 * return 0 if the row must remain in the ACTIVE state
 */
int saHpiRdrTable_can_deactivate(saHpiRdrTable_context *undo_ctx,
                        saHpiRdrTable_context *row_ctx,
                        netsnmp_request_group * rg)
{
	DEBUGMSGTL ((AGENT, "saHpiRdrTable_can_deactivate, called\n"));

    /*
     * TODO: check for deactivation requirements here
     */
    return 1;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int saHpiRdrTable_can_delete(saHpiRdrTable_context *undo_ctx,
                    saHpiRdrTable_context *row_ctx,
                    netsnmp_request_group * rg)
{
	DEBUGMSGTL ((AGENT, "saHpiRdrTable_can_delete, called\n"));
        subagent_lock(&hpi_lock_data);

    /*
     * probably shouldn't delete a row that we can't
     * deactivate.
     */
    if(saHpiRdrTable_can_deactivate(undo_ctx,row_ctx,rg) != 1) {
            subagent_unlock(&hpi_lock_data);
            return 0;
    }
    
    /*
     * TODO: check for other deletion requirements here
     */
    subagent_unlock(&hpi_lock_data);
    return 1;
}

/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated saHpiRdrTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
saHpiRdrTable_context *
saHpiRdrTable_create_row( netsnmp_index* hdr)
{

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_create_row, called\n"));
        subagent_lock(&hpi_lock_data);

    saHpiRdrTable_context * ctx =
        SNMP_MALLOC_TYPEDEF(saHpiRdrTable_context);

    if(!ctx) {
            subagent_unlock(&hpi_lock_data);
            return NULL;
    }
        
    /*
     * TODO: check indexes, if necessary.
     */
    if(saHpiRdrTable_extract_index( ctx, hdr )) {
        free(ctx->index.oids);
        free(ctx);
        subagent_unlock(&hpi_lock_data);
        return NULL;
    }

    /* netsnmp_mutex_init(ctx->lock);
       netsnmp_mutex_lock(ctx->lock); */

    /*
     * TODO: initialize any default values here. This is also
     * first place you really should allocate any memory for
     * yourself to use.  If you allocated memory earlier,
     * make sure you free it for earlier error cases!
     */
    /**
    */

    subagent_unlock(&hpi_lock_data);
    return ctx;
}

/************************************************************
 * the *_duplicate row routine
 */
saHpiRdrTable_context *
saHpiRdrTable_duplicate_row( saHpiRdrTable_context * row_ctx)
{

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_duplicate_row, called\n"));

    saHpiRdrTable_context * dup;

    if(!row_ctx)
        return NULL;

    subagent_lock(&hpi_lock_data);  

    dup = SNMP_MALLOC_TYPEDEF(saHpiRdrTable_context);
    if(!dup) {
            subagent_unlock(&hpi_lock_data);
            return NULL;
    }
        
    if(saHpiRdrTable_row_copy(dup,row_ctx)) {
        free(dup);
        dup = NULL;
    }

    subagent_unlock(&hpi_lock_data);
    return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index * saHpiRdrTable_delete_row( saHpiRdrTable_context * ctx )
{

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_delete_row, called\n"));

  
   subagent_lock(&hpi_lock_data);  
  /* netsnmp_mutex_destroy(ctx->lock); */

    if(ctx->index.oids)
        free(ctx->index.oids);

    /*
     * TODO: release any memory you allocated here...
     */

    /*
     * release header
     */
    free( ctx );

        subagent_unlock(&hpi_lock_data);

    return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void saHpiRdrTable_set_reserve1( netsnmp_request_group *rg )
{

//    saHpiRdrTable_context *row_ctx =
//            (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx =
//            (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int rc;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_reserve1, called\n"));

    /*
     * TODO: loop through columns, check syntax and lengths. For
     * columns which have no dependencies, you could also move
     * the value/range checking here to attempt to catch error
     * cases as early as possible.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch(current->tri->colnum) {

        default: /** We shouldn't get here */
            rc = SNMP_ERR_GENERR;
            snmp_log(LOG_ERR, "unknown column in "
                     "saHpiRdrTable_set_reserve1\n");
        }

        if (rc)
           netsnmp_request_set_error( current->ri, rc );
        rg->status = SNMP_MAX( rg->status, current->ri->status );
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

void saHpiRdrTable_set_reserve2( netsnmp_request_group *rg )
{
//    saHpiRdrTable_context *row_ctx = (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx = (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int rc;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_reserve2, called\n"));

    rg->rg_void = rg->list->ri;

    /*
     * TODO: loop through columns, check for valid
     * values and any range constraints.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch(current->tri->colnum) {

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }

        if (rc)
           netsnmp_request_set_error( current->ri, rc);
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void saHpiRdrTable_set_action( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
//    saHpiRdrTable_context *row_ctx = (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx = (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

    int            row_err = 0;
    subagent_lock(&hpi_lock_data);

    DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_action, called\n"));

    /*
     * TODO: loop through columns, copy varbind values
     * to context structure for the row.
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    if(row_err) {
        netsnmp_request_set_error((netsnmp_request_info*)rg->rg_void,
                                       row_err);
    }

    subagent_unlock(&hpi_lock_data);
    return;
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void saHpiRdrTable_set_commit( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
//    saHpiRdrTable_context *row_ctx = (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx = (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_commit, called\n"));

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void saHpiRdrTable_set_free( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
//    saHpiRdrTable_context *row_ctx = (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx = (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_free, called\n"));

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        default:
		break;
		/** We shouldn't get here */
		/** should have been logged in reserve1 */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void saHpiRdrTable_set_undo( netsnmp_request_group *rg )
{
    netsnmp_variable_list *var;
//    saHpiRdrTable_context *row_ctx = (saHpiRdrTable_context *)rg->existing_row;
//    saHpiRdrTable_context *undo_ctx = (saHpiRdrTable_context *)rg->undo_info;
    netsnmp_request_group_item *current;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_set_undo, called\n"));

    /*
     * loop through columns
     */
    for( current = rg->list; current; current = current->next ) {

        var = current->ri->requestvb;

        switch(current->tri->colnum) {

        default: /** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
}

/************************************************************
 *
 * Initialize the saHpiRdrTable table by defining its contents and how it's structured
 */
void
initialize_table_saHpiRdrTable(void)
{
    netsnmp_table_registration_info *table_info;

	DEBUGMSGTL ((AGENT, "initialize_table_saHpiRdrTable, called\n"));

    if(my_handler) {
        snmp_log(LOG_ERR, "initialize_table_saHpiRdrTable_handler called again\n");
        return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    /* if your table is read only, it's easiest to change the
       HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("saHpiRdrTable",
                                             netsnmp_table_array_helper_handler,
                                             saHpiRdrTable_oid,
                                             saHpiRdrTable_oid_len,
                                             HANDLER_CAN_RWRITE);
            
    if (!my_handler || !table_info) {
        snmp_log(LOG_ERR, "malloc failed in "
                 "initialize_table_saHpiRdrTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */
        /** TODO: add code for external index(s)! */

    /*
     * internal indexes
     */
        /** index: saHpiDomainId */
        netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);
        /** index: saHpiResourceId */
        netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);
        /** index: saHpiResourceIsHistorical */
        netsnmp_table_helper_add_index(table_info, ASN_INTEGER);
        /** index: saHpiRdrEntryId */
        netsnmp_table_helper_add_index(table_info, ASN_COUNTER);

    table_info->min_column = saHpiRdrTable_COL_MIN;
    table_info->max_column = saHpiRdrTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = saHpiRdrTable_get_value;
    cb.container = netsnmp_container_find("saHpiRdrTable_primary:"
                                          "saHpiRdrTable:"
                                          "table_container");
    netsnmp_container_add_index(cb.container,
                                netsnmp_container_find("saHpiRdrTable_secondary:"
                                                       "saHpiRdrTable:"
                                                       "table_container"));
    cb.container->next->compare = saHpiRdrTable_cmp;

    cb.can_set = 1;
    cb.create_row = (UserRowMethod*)saHpiRdrTable_create_row;
    cb.duplicate_row = (UserRowMethod*)saHpiRdrTable_duplicate_row;
    cb.delete_row = (UserRowMethod*)saHpiRdrTable_delete_row;
    cb.row_copy = (Netsnmp_User_Row_Operation *)saHpiRdrTable_row_copy;

    cb.can_activate = (Netsnmp_User_Row_Action *)saHpiRdrTable_can_activate;
    cb.can_deactivate = (Netsnmp_User_Row_Action *)saHpiRdrTable_can_deactivate;
    cb.can_delete = (Netsnmp_User_Row_Action *)saHpiRdrTable_can_delete;

    cb.set_reserve1 = saHpiRdrTable_set_reserve1;
    cb.set_reserve2 = saHpiRdrTable_set_reserve2;
    cb.set_action = saHpiRdrTable_set_action;
    cb.set_commit = saHpiRdrTable_set_commit;
    cb.set_free = saHpiRdrTable_set_free;
    cb.set_undo = saHpiRdrTable_set_undo;
    DEBUGMSGTL(("initialize_table_saHpiRdrTable",
                "Registering table saHpiRdrTable "
                "as a table array\n"));
    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);
}

/************************************************************
 * saHpiRdrTable_get_value
 *
 * This routine is called for get requests to copy the data
 * from the context to the varbind for the request. If the
 * context has been properly maintained, you don't need to
 * change in code in this fuction.
 */
int saHpiRdrTable_get_value(
            netsnmp_request_info *request,
            netsnmp_index *item,
            netsnmp_table_request_info *table_info )
{
	netsnmp_variable_list *var = request->requestvb;
	saHpiRdrTable_context *context = (saHpiRdrTable_context *)item;

	DEBUGMSGTL ((AGENT, "saHpiRdrTable_get_value, called\n"));

	switch(table_info->colnum) {
	
	    case COLUMN_SAHPIRDRENTRYID:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_value(var, ASN_UNSIGNED,
			 (unsigned char*)&context->saHpiRdrEntryId,
			 sizeof(context->saHpiRdrEntryId) );
	    break;
	
	    case COLUMN_SAHPIRDRNEXTENTRYID:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_value(var, ASN_UNSIGNED,
			 (unsigned char*)&context->saHpiRdrNextEntryId,
			 sizeof(context->saHpiRdrNextEntryId) );
	    break;
	
	    case COLUMN_SAHPIRDRTYPE:
		/** INTEGER = ASN_INTEGER */
		snmp_set_var_typed_value(var, ASN_INTEGER,
			 (unsigned char*)&context->saHpiRdrType,
			 sizeof(context->saHpiRdrType) );
	    break;
	
	    case COLUMN_SAHPIRDRENTITYPATH:
		/** SaHpiEntityPath = ASN_OCTET_STR */
		snmp_set_var_typed_value(var, ASN_OCTET_STR,
			 (unsigned char*)&context->saHpiRdrEntityPath,
			 context->saHpiRdrEntityPath_len );
	    break;
	
	    case COLUMN_SAHPIRDRISFRU:
		/** TruthValue = ASN_INTEGER */
		snmp_set_var_typed_value(var, ASN_INTEGER,
			 (unsigned char*)&context->saHpiRdrIsFru,
			 sizeof(context->saHpiRdrIsFru) );
	    break;
	
	    case COLUMN_SAHPIRDRROWPOINTER:
		/** RowPointer = ASN_OBJECT_ID */
		snmp_set_var_typed_value(var, ASN_OBJECT_ID,
			 (unsigned char*)&context->saHpiRdrRowPointer,
			 context->saHpiRdrRowPointer_len );
	    break;
	
	    case COLUMN_SAHPIRDRRPT:
		/** RowPointer = ASN_OBJECT_ID */
		snmp_set_var_typed_value(var, ASN_OBJECT_ID,
			 (unsigned char*)&context->saHpiRdrRPT,
			 context->saHpiRdrRPT_len );
	    break;
	
	    case COLUMN_SAHPIRDRTEXTTYPE:
		/** SaHpiTextType = ASN_INTEGER */
		snmp_set_var_typed_value(var, ASN_INTEGER,
			 (unsigned char*)&context->saHpiRdrTextType,
			 sizeof(context->saHpiRdrTextType) );
	    break;
	
	    case COLUMN_SAHPIRDRTEXTLANGUAGE:
		/** SaHpiTextLanguage = ASN_INTEGER */
		snmp_set_var_typed_value(var, ASN_INTEGER,
			 (unsigned char*)&context->saHpiRdrTextLanguage,
			 sizeof(context->saHpiRdrTextLanguage) );
	    break;
	
	    case COLUMN_SAHPIRDRIDSTRING:
		/** OCTETSTR = ASN_OCTET_STR */
		snmp_set_var_typed_value(var, ASN_OCTET_STR,
			 (unsigned char*)&context->saHpiRdrIdString,
			 context->saHpiRdrIdString_len );
	    break;
	
	default: /** We shouldn't get here */
	    snmp_log(LOG_ERR, "unknown column in "
		 "saHpiRdrTable_get_value\n");
	    return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

/************************************************************
 * saHpiRdrTable_get_by_idx
 */
const saHpiRdrTable_context *
saHpiRdrTable_get_by_idx(netsnmp_index * hdr)
{
	DEBUGMSGTL ((AGENT, "saHpiRdrTable_get_by_idx, called\n"));

    return (const saHpiRdrTable_context *)
        CONTAINER_FIND(cb.container, hdr );
}


