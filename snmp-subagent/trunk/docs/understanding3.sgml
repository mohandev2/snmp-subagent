<!-- ...................................................................... -->
<!-- $Id$ ................................................ -->
<!-- 
        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->
<chapter>
    <title>C code</title>
  <sect1>
      <title>Initializiation process of sub-agent</title>
      <para>
	The sub-agent is initialized by the call
</para>
	<programlisting role="C">
   33	  /* mib code: nit_netSnmpIETFWGTable from netSnmpIETFWGTable.c */
   34	  init_netSnmpIETFWGTable();  
	</programlisting>
	<para>
	from the sub-agent daemon code.  This call in the generated code 
	calls the function which sets up the skeleton of the table. 
	It does <emphasis>not</emphasis> add any actual values in the columns.
	</para>
	<programlisting role="C">
  717	/************************************************************
  718	 *
  719	 * Initialize the netSnmpIETFWGTable table by defining its contents and how it's structured
  720	 */
  721	void
  722	initialize_table_netSnmpIETFWGTable(void)
  723	{
  724	    netsnmp_table_registration_info *table_info;
  725	
  726	    if(my_handler) {
  727	        snmp_log(LOG_ERR, "initialize_table_netSnmpIETFWGTable_handler called again\n");
  728	        return;
  729	    }
  730	
  731	    memset(&amp cb, 0x00, sizeof(cb));
  732	
  733	    /** create the table structure itself */
  734	    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
  735	
  736	    /* if your table is read only, it's easiest to change the
  737	       HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
  738	    my_handler = netsnmp_create_handler_registration("netSnmpIETFWGTable",
  739	                                             netsnmp_table_array_helper_handler,
  740	                                             netSnmpIETFWGTable_oid,
  741	                                             netSnmpIETFWGTable_oid_len,
  742	                                             HANDLER_CAN_RWRITE);
  743	            
  744	    if (!my_handler || !table_info) {
  745	        snmp_log(LOG_ERR, "malloc failed in "
  746	                 "initialize_table_netSnmpIETFWGTable_handler\n");
  747	        return; /** mallocs failed */
  748	    }
  749	
  750	    /***************************************************
  751	     * Setting up the table's definition
  752	     */
  753	    /*
  754	     * TODO: add any external indexes here.
  755	     */
  756	
  757	    /*
  758	     * internal indexes
  759	     */
  760	        /** index: nsIETFWGName */
  761	        netsnmp_table_helper_add_index(table_info, ASN_OCTET_STR);
  762	
  763	    table_info->min_column = netSnmpIETFWGTable_COL_MIN;
  764	    table_info->max_column = netSnmpIETFWGTable_COL_MAX;
  765	
  766	    /***************************************************
  767	     * registering the table with the master agent
  768	     */
  769	    cb.get_value = netSnmpIETFWGTable_get_value;
  770	    cb.container = netsnmp_container_find("netSnmpIETFWGTable_primary:"
  771	                                          "netSnmpIETFWGTable:"
  772	                                          "table_container");
  773	#ifdef netSnmpIETFWGTable_IDX2
  774	    netsnmp_container_add_index(cb.container,
  775	                                netsnmp_container_find("netSnmpIETFWGTable_secondary:"
  776	                                                       "netSnmpIETFWGTable:"
  777	                                                       "table_container"));
  778	    cb.container->next->compare = netSnmpIETFWGTable_cmp;
  779	#endif
  780	#ifdef netSnmpIETFWGTable_SET_HANDLING
  781	    cb.can_set = 1;
  782	#ifdef netSnmpIETFWGTable_ROW_CREATION
  783	    cb.create_row = (UserRowMethod*)netSnmpIETFWGTable_create_row;
  784	#endif
  785	    cb.duplicate_row = (UserRowMethod*)netSnmpIETFWGTable_duplicate_row;
  786	    cb.delete_row = (UserRowMethod*)netSnmpIETFWGTable_delete_row;
  787	    cb.row_copy = (Netsnmp_User_Row_Operation *)netSnmpIETFWGTable_row_copy;
  788	
  789	    cb.can_activate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_activate;
  790	    cb.can_deactivate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_deactivate;
  791	    cb.can_delete = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_delete;
  792	
  793	    cb.set_reserve1 = netSnmpIETFWGTable_set_reserve1;
  794	    cb.set_reserve2 = netSnmpIETFWGTable_set_reserve2;
  795	    cb.set_action = netSnmpIETFWGTable_set_action;
  796	    cb.set_commit = netSnmpIETFWGTable_set_commit;
  797	    cb.set_free = netSnmpIETFWGTable_set_free;
  798	    cb.set_undo = netSnmpIETFWGTable_set_undo;
  799	#endif
  800	    DEBUGMSGTL(("initialize_table_netSnmpIETFWGTable",
  801	                "Registering table netSnmpIETFWGTable "
  802	                "as a table array\n"));
  803	    netsnmp_table_container_register(my_handler, table_info, &amp cb,
  804	                                     cb.container, 1);
  805	}
</programlisting>
	<para>
	The init routines performs a couple of basic steps.
	</para>
	<sect2><title>Handler</title>
<programlisting role="C">
  736       /* if your table is read only, it's easiest to change the
  737          HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
  738       my_handler = netsnmp_create_handler_registration("netSnmpIETFWGTable",
  739                                                netsnmp_table_array_helper_handler,
  740                                                netSnmpIETFWGTable_oid,
  741                                                netSnmpIETFWGTable_oid_len,
  742                                                HANDLER_CAN_RWRITE);
</programlisting>
	    <para>Create a handler which contains the OID of the table,
	whether it can be written to, and which (if any) if the
	NET-SNMP API helper functions to use.
		</para>
<note>
	<para>An OID - Object IDentifier is a an array of <emphasis>longs</emphasis>.
	The <emphasis>netSnmpIETFWGTable_oid</emphasis> is defined as:</para>
<programlisting role="C">
	oid netSnmpIETFWGTable_oid[] = { 1,3,6,1,4,1,8072,2,2,1 };
</programlisting>
</note>
	<note>
	<para>The <emphasis>netsnmp_table_array_helper_handler</emphasis> is one of many
	helper functions available. Consult the manpage - <emphasis>man netsnmp_table</emphasis>
	</para>
	</note>
	<sect2><title>Notify the helper function</title>

<programlisting role="C">
  760           /** index: nsIETFWGName */
  761           netsnmp_table_helper_add_index(table_info, ASN_OCTET_STR);
  762   
  763       table_info->min_column = netSnmpIETFWGTable_COL_MIN;
  764       table_info->max_column = netSnmpIETFWGTable_COL_MAX;
</programlisting>
		<para>Notify the helper how many indexes tuples to have
		and which type they are.
		</para>
	<note>
	<para>The netSnmpIETFWGTable_COL_MIN are defined in the automaticly generated header file.
	</para>
	</note>
	<note>
	<para>The <emphasis>ASN_OCTET_STR </emphasis> and other types are located in
	the net-snmp/library/asn1.h</para>
	</note>
	</sect2>
	<sect2>
		<title>Register the GET operation</title>
<programlisting role="C">
  766       /***************************************************
  767        * registering the table with the master agent
  768        */
  769       cb.get_value = netSnmpIETFWGTable_get_value;
</programlisting>
		<para>
		 Line 769 registers the GET routine which will be responsible
		for provinding the Net-SNMP API with the correct data and value. More on this in later sections.
		</para>
	</sect2>
	<sect2><title>Register compare function</title>
<programlisting role="C">
  773   #ifdef netSnmpIETFWGTable_IDX2
  774       netsnmp_container_add_index(cb.container,
  775                                   netsnmp_container_find("netSnmpIETFWGTable_secondary:"
  776                                                          "netSnmpIETFWGTable:"
  777                                                          "table_container"));
  778       cb.container->next->compare = netSnmpIETFWGTable_cmp;
  779   #endif
</programlisting>

		<para>Register with the main NetSNMP code (by injecting
		the address of a user-written routine in the callback mechanism) 
		the OID compare routine. This
		routine is <emphasis>NOT</emphasis> needed if your table rows
		don't have any external depedency on sort order. 
		</para>
		<note>
			<para>The compare routine is <emphasis>ONLY</emphasis>
			used during removal of rows. Not when rows are added.
			</para>
		</note>
		<para>	
		More on the compare function in the subsequent section.
		</para>
	</sect2>
	<sect2><title>Alternation and creation of row support</title>
	<programlisting role="C">
  782   #ifdef netSnmpIETFWGTable_ROW_CREATION
  783       cb.create_row = (UserRowMethod*)netSnmpIETFWGTable_create_row;
  784   #endif
	</programlisting>
	<para>
	Without this routine being injected in the call-back mechanism,
	no row creation is possible. The row creation process is
	user-agnostic - the sub-agent code using internal routines or the SNMP-user using SET operation can create new rows.
	</para>
	<para>
	However, the SNMP SET operation has to go through a set
	of other routines to determine if it has the valid syntax,
	the right type and length, and other user-defined tests. Those tests are not
	exercised when the sub-agent code uses the internal routines.
	</para>
	<para>
	The process which the NetSNMP API uses to decide if the data is OK 
	is a four state system. The data is writen to a new row or
	an existing one, if it has passed the RESERVE1, RESERVE2, and ACTION
	phase. The ACTION phase does the modification and if anything goes wrong
	the process moves to UNDO phase. Otherwise a COMMIT is perfomed.
	</para>
	<note>
		<para>This two-phase commit system is unique. Many other
		SNMP sub-agent APIs do not implement such technique and
		have only one SET operation which has to take care of 
		checking the type, size, limitation, perform the write, and
		undo if needed.
		</para>
	</note>
	<para>
	The following picture, from the Net-SNMP Tutorial webpage 
	clearly explains the states.
	</para>
	<mediaobject>
        <imageobject>
          <imagedata fileref="images/set-actions.jpg">
        </imageobject>
      </mediaobject>
	<para>And they are are also part of the call-back mechanism. The internals of those
functions is the responsibilty of the user (more on this in later sections):
	</para>
	<programlisting role="C">
  793       cb.set_reserve1 = netSnmpIETFWGTable_set_reserve1;
  794       cb.set_reserve2 = netSnmpIETFWGTable_set_reserve2;
  795       cb.set_action = netSnmpIETFWGTable_set_action;
  796       cb.set_commit = netSnmpIETFWGTable_set_commit;
  797       cb.set_free = netSnmpIETFWGTable_set_free;
  798       cb.set_undo = netSnmpIETFWGTable_set_undo;
	</programlisting>
	</sect2>

	<sect2>
		<title>Miscellaneous</title>
	<para>
	The write operation also needs a couple of  utility functions
	for the RESERVE1 (defined as netSnmpIETFWGTable_set_reserve1), RESERVE2 (defined as netSnmpIETFWGTable_set_reserve2), ACTION (defined as netSnmpIETFWGTable_set_action), COMMIT (defined as netSnmpIETFWGTable_set_commit) and UNDO (defined as .. well you can guess that one) routines.
	They are part of the call-back mechanism and should be defined.
	Usually you don't need to modify them as the mib2c tool
	does a great job of implementing them. The routines in question are:
	</para>
	<programlisting role="C">
  785       cb.duplicate_row = (UserRowMethod*)netSnmpIETFWGTable_duplicate_row;
  786       cb.delete_row = (UserRowMethod*)netSnmpIETFWGTable_delete_row;
  787       cb.row_copy = (Netsnmp_User_Row_Operation *)netSnmpIETFWGTable_row_copy;
  788   
  789       cb.can_activate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_activate;
  790       cb.can_deactivate = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_deactivate;
  791       cb.can_delete = (Netsnmp_User_Row_Action *)netSnmpIETFWGTable_can_delete;
	</programlisting>
	</sect2>
	<sect2>
		<title>Registering handler with container</title>
	<para>
		The last thing that must be done is to register
		the handler, table information (how many rows, columns, etc),
		and the call-back mechansim with the <emphasis>container</emphasis>
	</para>
	<para>
		The container is the Net-SNMP part of code that will
		keep our rows in memory. It will take care of sorting it (when
		new rows are added or removed), providing a specific
		row for a GET/SET request (so you don't have to extract from the OID
		the index/column values and find the row by yourself), and more. This container
		mechanism provides a seperation of the sub-agent programmer
		to have to deal with SNMP GET/SET details and concentrate
		on operating the data.
	</para>
	<note>
		<para>Look in <emphasis>net-snmp/library/container.h</emphasis>
		for more details. The macro calls which are defined in there 
		(CONTAINER_FIRST, CONTAINER_GET_SUBSET, etc) will be explained
		in more details in subsequent sections.
		</para>
	</note>
      </sect2>
 </sect1>

 <sect1>
  <title>Compare function: netSnmpIETFWGTable_cmp</title>

	<para>
	The compare function is only used if <emphasis>netSnmpIETFWGTable_IDX2
	</emphasis> is defined. This compare function is used by NetSNMP API
	when rows are being deleted. If this function is not enabled, the
	NetSNMP API will use its own generic compare function - which compares
	index tuples and returns the answer based on ascending order.
	</para>
	<para>
	The commented out example code demonstrates how to implement this
	function.
	</para>
 </sect1>

 <sect1>
   <title>netSnmpIETFWGTable_get</title>

	<para>
	</para> 
 </sect1>
</chapter>
