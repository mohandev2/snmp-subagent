<!-- ...................................................................... -->
<!-- $Id$ -->
<!-- 
        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->
<chapter>
    <title>Header file</title>
    <sect1>
    <title>Header files</title>
    <para>
	The header file generated by the 'mib2c' tool consist of
	five elements:
    </para>
	<itemizedlist mark='opencircle'>
	  <listitem>
	  	<para>A <emphasis>context</emphasis> structure. It is a
	     	one to one mapping of the leaf nodes (columnar objects) 
		in a SEQUENCE table to a C structure, with the first variable
		being the index tuple.
	 	</para>
	  </listitem>
	  <listitem>
	  	<para>
		Functions for manipulating the <emphasis>context</emphasis> structure.
		These include generic functions for sorting, getting an item, checking for
		correct boundary conditions, and generating the index tuple.
		</para>
	  <listitem>
	  	<para>
		Object IDentifier for the table.
		</para>
	  </listitem>
	  <listitem>
	  	<para>
		Textual names of the leaf nodes (columnar objects) using #define.
		</para>
	  </listitem>
	  <listitem>
	  	<para>
		 #define enabling/disabling different functions of the 
		sub-agent table manipulations.
		</para>
	  </listitem>
	</itemizedlist>
    <sect2 id="context_structure">
      <title>Context structure</title>
      <para>
      The <emphasis>context</emphasis> structure is used exclusivly by the NetSNMP API
      for manipulating rows of leaf nodes (columnar objects).
      </para>
      <para>
      The first named variables of the structure is the <emphasis>index</emphasis> variable.
	<programlisting role='C'>
      typedef struct netSnmpIETFWGTable_context_s {
    	netsnmp_index index; /** THIS MUST BE FIRST!!! */
	....
      </programlisting>
      <para>The <emphasis>netsnmp_index</emphasis> is defined in <emphasis>net-snmp/types.h</emphasis> as
      </para>
      	<programlisting role="C">
    typedef struct netsnmp_index_s {
       int          len;
       oid         *oids;
    } netsnmp_index;
	</programlisting>
       <para>
       	The <emphasis>oid</emphasis> is defined as unsigned long  (look in net-snmp/library/asn1.h).
	The <emphasis>len</emphasis> is the number of entries in the *oids array, 
	<emphasis>not</emphasis> the length of the OID in the bytes.
       </para>
       <para>
       	This <emphasis>netsnmp_index</emphasis> structure is used to place the index tuple
	of the row. Not the full OID (as in fully expanded OID of the table), but just 
	the sub-set of numbers uniquely defining the row alsa known as index value.
       </para> 
       <sect3>
        <title>Example of using netsnmp_index</title>
	<para>
	 The example uses the IETF WG table structure to set the index tuple to the string
	 "fodo."
	 </para>
	 <programlisting role='C'>
	  netsnmp_index *index;
	  oid index_oid[5];

	  index = SNMP_MALLOC_TYPEDEF(netsnmp_index);
	  index_oid[0] = 4;  // The first value is the length of the string. 
	  index_oid[1] ='f'; 
	  index_oid[2] ='o'; 
	  index_oid[3] ='d';
	  index_oid[4] ='o';

	  index->oids = index_oid;
	  index->len = 5;
	</programlisting>	
	<para>
	This example will generate the index tuple, nothing else. 
	</para>
	</sect3>
	<sect3>
		<title>Rest of context structure</title>

	<para>
	The rest of the generated structure contains  columnar
	(leaf nodes) mapped to C types. The generator assumes the most
	general type of the object - therefore a <emphasis>TruthValue</emphasis> textual 
	convention in a MIB will map to an ASN_INTEGER type - in C language
	this will be <emphasis>unsigned long</emphasis>. If you don't remember what
	textual conventions are and what their basics data types are, consult the
	SNMP-v2-TC MIB file. 
	</para>
	<note>
	<para>
	The length of the data (if the columnar node is defined as <emphasis>
	OCTET STRING(SIZE(1..10))</emphasis> is NOT taken under consideration
	and has to be manually changed from the maximum length. As in with :
	<programlisting role='C'>
       /** OCTETSTR = ASN_OCTET_STR */
            char nsIETFWGName[65535];
            long nsIETFWGName_len;
	</programlisting>
	Where <emphasis>nsIETFWGName</emphasis> is mapped to the columnar node <emphasis>nsIETFWGName</emphasis>
	of string size greater than one but less than thirty-two. 
	<programlisting role='C'>
nsIETFWGName OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE(1..32))
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
        "The name of the IETF Working Group this table describes."
    ::= { netSnmpIETFWGEntry 1 }
</programlisting>
	Please consult <emphasis>NET-SNMP-EXAMPLES-MIB.txt</emphasis> for the rest of the object if interested.
	</para>
	</note>
	<para>
	Subsequent examples will demonstrate how to fully leverage the rest of 
	the context structure. Please consult <xref linkend="developer_row_creation">.
	</para>
       </sect3>
      </sect2>
      <sect2>
      	<title>Functions</title>
	<para>
	  The 'mib2c' places the function prototypes right behind the
	  context structure and also behind the textual names of the leaf nodes.
	</para>
	<programlisting role='C'>
void init_netSnmpIETFWGTable(void);
void initialize_table_netSnmpIETFWGTable(void);
const netSnmpIETFWGTable_context * netSnmpIETFWGTable_get_by_idx(netsnmp_index *);
const netSnmpIETFWGTable_context * netSnmpIETFWGTable_get_by_idx_rs(netsnmp_index *,
                                        int row_status);
int netSnmpIETFWGTable_get_value(netsnmp_request_info *, netsnmp_index *, netsnmp_table_request_info *);
	</programlisting>
	<para>
	  The first set of declared functions are used to:
	</para>
	<itemizedlist mark='closedcircle'>
	   <listitem>
	   	<para>
		  Initialize the table. This function will be fully explained 
		  in <xref linkend="initialize_table">
		</para>
	   </listitem>
	   <listitem>
	   	<para>
		  Helper functions for retrieving the secondary index value. What is 
		  a secondary index value? It is the second index in a index tuple.
		  For detail information, please look in <xref linkend="n_tuple_indexes">
		 and <xref linkend="developer_row_creation">.
		 </para>
		 <para>
		   This function allows for the sub-agent to check 
		   (or reshape) of the column objects in a row before delievering
		   to the user.
		 </para>
	    </listitem>
	    <listitem>
	    	 <para>
		  Helper functions for retrieving the data value of the columnar object
		  in a specific row. The column number, and row is passed in to this
		  function.
		 </para>
	     </listitem>
	   </itemizedlist>
	   <para>
	    The next set of functions are controlled by a set of #define statements. 
	    These operations are for writing, deleting, creating, and retrieving secondary index 
	    of rows. 
<programlisting role='C'>
#ifdef netSnmpIETFWGTable_SET_HANDLING

int netSnmpIETFWGTable_extract_index( netSnmpIETFWGTable_context * ctx, netsnmp_index * hdr );

void netSnmpIETFWGTable_set_reserve1( netsnmp_request_group * );
void netSnmpIETFWGTable_set_reserve2( netsnmp_request_group * );
void netSnmpIETFWGTable_set_action( netsnmp_request_group * );
void netSnmpIETFWGTable_set_commit( netsnmp_request_group * );
void netSnmpIETFWGTable_set_free( netsnmp_request_group * );
void netSnmpIETFWGTable_set_undo( netsnmp_request_group * );

netSnmpIETFWGTable_context * netSnmpIETFWGTable_duplicate_row( netSnmpIETFWGTable_context* );
netsnmp_index * netSnmpIETFWGTable_delete_row( netSnmpIETFWGTable_context* );

int netSnmpIETFWGTable_can_delete(netSnmpIETFWGTable_context *undo_ctx,
                    netSnmpIETFWGTable_context *row_ctx,
                    netsnmp_request_group * rg);
    
    
#ifdef netSnmpIETFWGTable_ROW_CREATION
netSnmpIETFWGTable_context * netSnmpIETFWGTable_create_row( netsnmp_index* );
#endif
#endif

#ifdef netSnmpIETFWGTable_IDX2
netSnmpIETFWGTable_context * netSnmpIETFWGTable_get( const char *name, int len );
#endif
</programlisting>
	   <para>
	    There are three sets of functions:
	   </para>
	    <itemizedlist>
		<listitem>
		  <para>
		     For SNMP SET operations. These operations are used to write and delete
		     (if appropiate) rows. Consult <xref linkend="delete_rows"> and 
		   <xref linkend="write_row"> for more details.
		  </para>
		 </listitem>
		 <listitem>
		   <para>
		     For creation of rows. Consult <xref linkend="create_rows"> for more details.
		   </para>
		  </listitem>
		  <listitem>
		    <para>
		      Manipulating secondary (or more) index tuple. Consult
		      <xref linkend="n_tuple_indexes">.
		    </para>
		  </listitem>
	    </itemizedlist>
     <sect2>
      <title>Object IDentifier of the table</title>
      <para>
       The 'mib2c' tool also extracts the OID of the table. This sequence of numbers
       is used by the sub-agent when registering the table.
      </para>
     </sect2>

     <sect2>
      <title>Textual names for leaf nodes</title>
      <para>
       The leaf nodes object names (from the MIB) are translated to a
       list of #define in the format of:
      </para>
      <para>
        #define COLUMN_&lt;name of the leaf node&gt; &lt;columnar index value&gt;
      </para>
      <para>
       for each of the leaf nodes.
      </para>
      <programlisting role='C'>
#define COLUMN_NSIETFWGNAME 1
#define COLUMN_NSIETFWGCHAIR1 2
#define COLUMN_NSIETFWGCHAIR2 3      
      </programlisting>
      <para>
      	These textual names are used in the generated C source code instead of 
	the numerical values for developer convenience.
      </para>
     </sect2>

     <sect2>
      <title>Enabling and disabling operations</title>
      <para>
       The three set of #define statements disable or enable sub-agent operations.
      </para>
      <itemizedlist>
        <listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_SET_HANDLING</emphasis> 
	  will make the sub-agent not handle SNMP SET requests.
	  </para>
	</listitem>
	<listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_ROW_CREATION</emphasis>
	  will not allow the sub-agent to create rows.
	  </para>
	</listitem>
	<listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_IDX2</emphasis> disables
	  the handling of secondary (or more) of index.
	  </para>
	 </listitem>
      </itemizedlist>
	<para>These #define statements also exist in the generated C source code
	to properly disable/enable certain functions. For the purpose of this
	tutorial assume that all of the #define have to be enabled except
	<emphasis>netSnmpIETFWGTable_IDX2</emphasis> (consult <xref linkend="netSnmpIETFWGTable_IDX2"> 
	for details on the usage of this switch). 
	</para>
    </sect2>
  </sect1>	
</chapter>
