/*
 * (C) Copyright IBM Corp. 2003
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Authors:
 *   Konrad Rzeszutek <konradr@us.ibm.com>
 *
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id$
 *
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>
#include <saHpiTable.h>
#include <saHpiEventTable.h>
#include <saHpiSystemEventLogTable.h>
#include <saHpiHotSwapTable.h>
#include <saHpiWatchdogTable.h>


extern int send_traps;
extern int MAX_EVENT_ENTRIES;
static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;

static oid saHpiEventTable_oid[] = { saHpiEventTable_TABLE_OID };
static size_t saHpiEventTable_oid_len = OID_LENGTH (saHpiEventTable_oid);


/*
 * OIDs for our TRAPS
 */
static oid saHpiSensorNotification_oid[] = { hpiNotifications_OID, 1, 0 };

static oid saHpiHotSwapNotification_oid[] = { hpiNotifications_OID, 2, 0 };

static oid saHpiWatchdogNotification_oid[] = { hpiNotifications_OID, 3, 0 };

static oid saHpiOEMNotification_oid[] = { hpiNotifications_OID, 4, 0 };

static oid saHpiUserNotification_oid[] = { hpiNotifications_OID, 5, 0 };

/*
 * The length of all of the TRAPS are the same. 
 */
static size_t TRAPS_OID_LENGTH = OID_LENGTH (saHpiSensorNotification_oid);

/* 
 * Count and index values for our helper table.
 */
#define SENSOR_NOTIF_COUNT 8
#define NOTIF_EVENTINDEX 0
#define NOTIF_SEVERITY 1
#define SENSOR_NOTIF_SENSORCATEGORY 2
#define SENSOR_NOTIF_SENSORNUM 3
#define SENSOR_NOTIF_SENSORTYPE 4
#define SENSOR_NOTIF_SENSOROPTIONALDATA 5
#define SENSOR_NOTIF_SENSORTRIGGERREADINGRAW 6
#define SENSOR_NOTIF_SENSOROEM 7

/*
 * Helper table.
 * 
 * This is were our values and length of the values
 * will be updated when sending a trap.
 */
static trap_vars saHpiSensorNotification[] = {
  {COLUMN_SAHPIEVENTINDEX, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSEVERITY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTSENSORCATEGORY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTSENSORNUM, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSENSORTYPE, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTSENSOROPTIONALDATA, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSENSORTRIGGERREADINGRAW, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSENSOROEM, ASN_UNSIGNED, NULL, 0}
};

/*
 * Count and index values for our helper table.
 */
#define HOTSWAP_NOTIF_COUNT 4
#define HOTSWAP_STATE 2
#define HOTSWAP_PREVIOUS_STATE 3

/*
 * Helper table.
 */
static trap_vars saHpiHotSwapNotification[] = {
  {COLUMN_SAHPIEVENTINDEX, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSEVERITY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTHOTSWAPSTATE, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTPREVIOUSHOTSWAPSTATE, ASN_INTEGER, NULL, 0}
};

// IBM-KR:  add the OID of the HotSwap row?

#define WATCHDOG_NOTIF_COUNT 6
#define WATCHDOG_NOTIF_NUM 2
#define WATCHDOG_NOTIF_ACTION 3
#define WATCHDOG_NOTIF_PRETIMERACTION 4
#define WATCHDOG_NOTIF_USE 5
static trap_vars saHpiWatchdogNotification[] = {
  {COLUMN_SAHPIEVENTINDEX, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSEVERITY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTWATCHDOGNUM, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTWATCHDOGACTION, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTWATCHDOGPRETIMERACTION, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTWATCHDOGUSE, ASN_INTEGER, NULL, 0}
};

// IBM-KR:  add the OID of the Watchdog row? 

#define OEM_NOTIF_COUNT 4
#define OEM_NOTIF_MANUF_ID 2
#define OEM_NOTIF_EVENT_DATA 3

static trap_vars saHpiOEMNotification[] = {
  {COLUMN_SAHPIEVENTINDEX, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSEVERITY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTOEMMANUFACTURERIDT, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTOEMEVENTDATA, ASN_OCTET_STR, NULL, 0}
};

#define USER_NOTIF_COUNT 3
#define USER_NOTIF_EVENT_DATA 2
static trap_vars saHpiUserNotification[] = {
  {COLUMN_SAHPIEVENTINDEX, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIEVENTSEVERITY, ASN_INTEGER, NULL, 0},
  {COLUMN_SAHPIEVENTUSEREVENTDATA, ASN_OCTET_STR, NULL, 0}
};



static oid saHpiEventCount_oid[] = { events_OID, 1, 0 };

static u_long event_count = 0;
static SaHpiTimeoutT timeout = SAHPI_TIMEOUT_IMMEDIATE;
static u_long index_nr = 0;

static int
saHpiEventTable_modify_context (unsigned long,
				SaHpiEventT *,
				SaHpiRptEntryT * t,
				SaHpiRdrT *,
				saHpiEventTable_context * ctx,
				trap_vars ** var,
				size_t * var_len, oid ** var_oid);

/*
 * Checks for all SEL and EVENTs
 */
int
populate_event ()
{

  SaErrorT err;
  SaHpiSessionIdT session_id;

  SaHpiEventT event;
  SaHpiRdrT rdr;
  SaHpiRptEntryT rpt;

  oid domain_oid[MAX_OID_LEN];
  oid resource_oid[MAX_OID_LEN];
  oid column[2];
  oid event_oid[EVENT_INDEX_NR];

  size_t domain_oid_len;
  size_t resource_oid_len;

  oid rpt_oid[RPT_INDEX_NR];
  netsnmp_index rpt_index;
  netsnmp_index event_index;

  unsigned int user_oem_event_type = AGENT_FALSE;
  unsigned int eventflag = AGENT_TRUE;
  int rc = AGENT_ERR_NOERROR;

  // For TRAP/EVENTs
  oid *trap_oid;
  trap_vars *trap = NULL;
  size_t trap_len;
  netsnmp_variable_list *trap_var;

  saHpiEventTable_context *event_context;

  DEBUGMSGTL ((AGENT, "\t--- populate_event. Entry\n"));

  rc = getSaHpiSession (&session_id);
  if (rc != AGENT_ERR_NOERROR)
    {
      DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		   rc));
      return rc;
    }


  while (eventflag == AGENT_TRUE)
    {
      // We clean it with spaces b/c in case its an SAHPI_ET_USER - which
      // data-payload we just straight copy (32octets) and set the the
      // the length to 32. And in case its an user-readable ASCIIZ string
      // we just ignored the 0x00 delimiter (since we set the length to be 32).
      // This will make the 32bit string padded with spaces and look readeable to
      // the user. We figure that if its not SAHPI_ET_USER, it will use the 
      // rest of the 32 octets with its own stuff.

      memset (&event, 0x20, sizeof (SaHpiEventT));
      err = saHpiEventGet (session_id, timeout, &event, &rdr, &rpt);
      if (err == SA_OK)
	{
	  /*
	     rpt.ResourceCapabilities = 0;
	     event.Source = 200;
	     event.EventType = SAHPI_ET_USER;
	     event.Timestamp = -1;
	     event.Severity = 3;
	     strncpy(event.EventDataUnion.UserEvent.UserEventData,"Grozny smok.", 12);
	   */
	  if (rpt.ResourceCapabilities == 0)
	    {			// OEM or USER type event
	      rpt.ResourceId = 0;
	      rpt.DomainId = 0;
	      rpt.EntryId = 0;
	      user_oem_event_type = AGENT_TRUE;
	    }

	  // 1). Generate the domain_oid and resource_oid
	  //     Only do it when its necessary

	  if ((rpt_oid[0] != rpt.DomainId) ||
	      (rpt_oid[1] != rpt.ResourceId) || (rpt_oid[2] != rpt.EntryId))
	    {

	      // Make the RPT index value.
	      rpt_oid[0] = rpt.DomainId;
	      rpt_oid[1] = rpt.ResourceId;
	      rpt_oid[2] = rpt.EntryId;

	      rpt_index.len = RPT_INDEX_NR;
	      rpt_index.oids = (oid *) & rpt_oid;

	      // This is copied from saHpiTable.c:197
	      // Generate our full OID for the DomainID
	      column[0] = 1;
	      // Point to first object.
	      column[1] = COLUMN_SAHPIDOMAINID;

	      build_full_oid (saHpiTable_oid, saHpiTable_oid_len,
			      column, 2,
			      &rpt_index,
			      domain_oid, MAX_OID_LEN, &domain_oid_len);

	      column[1] = COLUMN_SAHPIRESOURCEID;

	      build_full_oid (saHpiTable_oid, saHpiTable_oid_len,
			      column, 2,
			      &rpt_index,
			      resource_oid, MAX_OID_LEN, &resource_oid_len);
	      /*
	         DEBUGMSGTL ((AGENT, "Our OIDS in Event are:\n"));
	         DEBUGMSGOID ((AGENT, domain_oid, domain_oid_len));
	         DEBUGMSGOID ((AGENT, resource_oid, resource_oid_len));
	         DEBUGMSGTL ((AGENT, "Values are: %d.%d.%d\n",
	         rpt.DomainId, rpt.ResourceId, rpt.EntryId));
	       */
	      if (user_oem_event_type == AGENT_TRUE)
		{
		  domain_oid_len = 0;
		  resource_oid_len = 0;
		  user_oem_event_type = AGENT_FALSE;
		}
	    }
	  // 2). Create our index value

	  event_oid[0] = rpt.DomainId;
	  event_oid[1] = rpt.ResourceId;
	  event_oid[2] = index_nr;

	  event_index.oids = (oid *) & event_oid;
	  event_index.len = EVENT_INDEX_NR;

	  event_context = NULL;
	  event_context = CONTAINER_FIND (cb.container, &event_index);

	  if (!event_context)
	    {
	      // New entry. Add it
	      event_context = saHpiEventTable_create_row (&event_index);
	    }

	  // By this stage, event_context surely has something in it.

	  // And since this is a queue, only NEW entries are seen.
	  // Thus we don't need to check to see if this value already exist      

	  saHpiEventTable_modify_context (index_nr,
					  &event,
					  &rpt,
					  &rdr,
					  event_context,
					  &trap, &trap_len, &trap_oid);

	  CONTAINER_INSERT (cb.container, event_context);
	  event_count = CONTAINER_SIZE (cb.container);
	  // Update our third undex value.
	  index_nr++;
	  if (send_traps == AGENT_TRUE)
	    {
	      if (trap != NULL)
		{
		  trap_var = build_notification (&event_index,
						 trap, trap_len,
						 trap_oid, TRAPS_OID_LENGTH,
						 saHpiEventTable_oid,
						 saHpiEventTable_oid_len,
						 rpt.DomainId, domain_oid,
						 domain_oid_len,
						 rpt.ResourceId, resource_oid,
						 resource_oid_len);
		  if (trap_var != NULL)
		    {
		      send_v2trap (trap_var);
		      snmp_free_varbind (trap_var);
		    }
		  else
		    {
		      snmp_log (LOG_WARNING,
				"Could not build an EVENT trap message.\n");
		      rc = AGENT_ERR_BUILD_TRAP;
		    }
		}
	    }
	}
      else

	{
	  DEBUGMSGTL ((AGENT, "%s (rc: %s)\n", (err == SA_ERR_HPI_TIMEOUT) ?
		       "No more EVENT  entries. " :
		       "Call to saHpiEventGet failed.",
		       get_error_string (err)));
	  eventflag = AGENT_FALSE;
	}

    }				// while loop

  return rc;
}


unsigned long
purge_event (void)
{


  unsigned long count = 0;
  unsigned long i;

  saHpiEventTable_context *event_context;
  DEBUGMSGTL ((AGENT, "purge_event. Entry.\n"));

  if ((i = CONTAINER_SIZE (cb.container)) > MAX_EVENT_ENTRIES)
    {
      // Delete 'count' entries.    
      i = i - MAX_EVENT_ENTRIES;
      DEBUGMSGTL ((AGENT, "Deleting %d EVENT row(s).\n", i));
      count = i;
      while (i > 0)
	{
	  event_context = CONTAINER_FIRST (cb.container);
	  CONTAINER_REMOVE (cb.container, event_context);
	  saHpiEventTable_delete_row (event_context);
	  i--;
	}
    }

  DEBUGMSGTL ((AGENT, "purge_event. Exit. (purged: %d)\n", count));
  return count;
}

int
saHpiEventTable_modify_context (unsigned long entry_id,
				SaHpiEventT * event_entry,
				SaHpiRptEntryT * rpt_entry,
				SaHpiRdrT * rdr_entry,
				saHpiEventTable_context * ctx,
				trap_vars ** var, size_t * var_len,
				oid ** var_trap_oid)
{
  unsigned int update_entry = MIB_FALSE;
  long hash;
  SaHpiSensorEventT sensor;
  SaHpiSensorReadingT reading;
  SaHpiHotSwapEventT hotswap;
  SaHpiWatchdogEventT watchdog;
  SaHpiOemEventT oem;
  SaHpiUserEventT user;

  if (event_entry && ctx)
    {
      hash = calculate_hash_value (event_entry, sizeof (SaHpiEventT));

      DEBUGMSGTL ((AGENT, " Hash value: %d, in ctx: %d\n", hash, ctx->hash));

      if (ctx->hash != 0)
	{
	  // Only do the check if the hash value is something else than zero.
	  // 'zero' value is only for newly created records, and in some
	  // rare instances when the hash has rolled to zero - in which
	  // case we will just consider the worst-case scenario and update
	  // the record and not trust the hash value.
	  if (hash == ctx->hash)
	    {
	      // The same data. No need to change.
	      return AGENT_ENTRY_EXIST;
	    }
	  if ((ctx->resource_id== rpt_entry->ResourceId) &&
	      (ctx->domain_id == rpt_entry->DomainId) &&
	      (ctx->saHpiEventIndex == entry_id)) {
		  DEBUGMSGTL((AGENT,"Updating Event entry [%d, %d, %d].\n",
					  rpt_entry->DomainId,
					  rpt_entry->ResourceId,
					  entry_id));

		  update_entry = MIB_TRUE;
	   }
	}

      if (hash == 0)
	hash = 1;
      ctx->hash = hash;
      ctx->resource_id = rpt_entry->ResourceId;
      ctx->domain_id = rpt_entry->DomainId;

      ctx->saHpiEventIndex = entry_id;

      ctx->saHpiEventType = event_entry->EventType + 1;

//IBM-KR: Endian

      ctx->saHpiEventTimestamp.low = event_entry->Timestamp & 0xffffffff;
      ctx->saHpiEventTimestamp.high = event_entry->Timestamp >> 32;

      ctx->saHpiEventSeverity = event_entry->Severity + 1;

      if (event_entry->EventType == SAHPI_ET_SENSOR)
	{
	  sensor = event_entry->EventDataUnion.SensorEvent;
	  ctx->saHpiEventSensorNum = sensor.SensorNum;
	  ctx->saHpiEventSensorType = sensor.SensorType;
	  ctx->saHpiEventSensorCategory = sensor.EventCategory;
	  ctx->saHpiEventSensorAssertion =
	    (sensor.Assertion == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;
	  if (sensor.EventCategory & SAHPI_EC_THRESHOLD)
	    ctx->saHpiEventSensorStateCategoryThreshold = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_USAGE)
	    ctx->saHpiEventSensorStateCategoryUsage = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_STATE)
	    ctx->saHpiEventSensorStateCategoryState = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_PRED_FAIL)
	    ctx->saHpiEventSensorStateCategoryPredFail = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_LIMIT)
	    ctx->saHpiEventSensorStateCategoryLimit = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_PERFORMANCE)
	    ctx->saHpiEventSensorStateCategoryPerformance = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_SEVERITY)
	    ctx->saHpiEventSensorStateCategorySeverity = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_PRESENCE)
	    ctx->saHpiEventSensorStateCategoryPresence = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_ENABLE)
	    ctx->saHpiEventSensorStateCategoryEnable = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_AVAILABILITY)
	    ctx->saHpiEventSensorStateCategoryAvailability =
	      sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_REDUNDANCY)
	    ctx->saHpiEventSensorStateCategoryRedundancy = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_USER)
	    ctx->saHpiEventSensorStateCategoryUser = sensor.EventState;
	  if (sensor.EventCategory & SAHPI_EC_GENERIC)
	    ctx->saHpiEventSensorStateCategoryGeneric = sensor.EventState;
	  /*
	     #define SAHPI_SOD_TRIGGER_READING   (SaHpiSensorOptionalDataT)0x01
	     #define SAHPI_SOD_TRIGGER_THRESHOLD (SaHpiSensorOptionalDataT)0x02
	     #define SAHPI_SOD_OEM               (SaHpiSensorOptionalDataT)0x04
	     #define SAHPI_SOD_PREVIOUS_STATE    (SaHpiSensorOptionalDataT)0x08
	     #define SAHPI_SOD_SENSOR_SPECIFIC   (SaHpiSensorOptionalDataT)0x10
	   */
	  ctx->saHpiEventSensorOptionalData = sensor.OptionalDataPresent;
	  reading = sensor.TriggerReading;
	  ctx->saHpiEventSensorTriggerReadingType = reading.ValuesPresent;

	  if (reading.ValuesPresent & SAHPI_SRF_RAW)
	    {
	      ctx->saHpiEventSensorTriggerReadingRaw = reading.Raw;	//IBM-KR:htonl (reading.Raw);
	    }
	  if (reading.ValuesPresent & SAHPI_SRF_INTERPRETED)
	    {
	      ctx->saHpiEventSensorTriggerReadingInterpretedType =
		reading.Interpreted.Type + 1;
	      switch (reading.Interpreted.Type)
		{
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT16:
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT16:
		  reading.Interpreted.
		    Value.
		    SensorUint16 = htons (reading.Interpreted.
					  Value.SensorUint16);
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT32:
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT32:
		  reading.Interpreted.
		    Value.
		    SensorUint32 = htonl (reading.Interpreted.
					  Value.SensorUint32);
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_FLOAT32:
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT8:
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT8:
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_BUFFER:
		  break;
		}
	      memcpy (ctx->saHpiEventSensorTriggerReadingInterpreted,
		      &reading.Interpreted.Value, SAHPI_SENSOR_BUFFER_LENGTH);
	      ctx->saHpiEventSensorTriggerReadingInterpreted_len =
		EVENT_TRIGGER_READING_INTERPRETED_MAX;
	    }
	  if (reading.ValuesPresent & SAHPI_SRF_EVENT_STATE)
	    {
	      ctx->saHpiEventSensorTriggerReadingEventState[0] =
		reading.EventStatus.SensorStatus;
	      reading.EventStatus.SensorStatus =
		htons (reading.EventStatus.EventStatus);
	      memcpy (ctx->saHpiEventSensorTriggerReadingEventState + 1,
		      &reading.EventStatus.EventStatus, 2);
	      ctx->saHpiEventSensorTriggerReadingEventState_len =
		EVENT_TRIGGER_READING_EVENT_STATE_MAX;
	    }


	  reading = sensor.TriggerThreshold;


	  if (reading.ValuesPresent & SAHPI_SRF_RAW)
	    {
	      ctx->saHpiEventSensorTriggerThresholdRaw = reading.Raw;	//htonl (reading.Raw);
	    }
	  if (reading.ValuesPresent & SAHPI_SRF_INTERPRETED)
	    {
	      ctx->saHpiEventSensorTriggerThresholdInterpretedType =
		reading.Interpreted.Type + 1;
	      switch (reading.Interpreted.Type)
		{
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT16:
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT16:
		  reading.Interpreted.
		    Value.
		    SensorUint16 = htons (reading.Interpreted.
					  Value.SensorUint16);
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT32:
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT32:
		  reading.Interpreted.
		    Value.
		    SensorUint32 = htonl (reading.Interpreted.
					  Value.SensorUint32);
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_FLOAT32:
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_UINT8:
		case SAHPI_SENSOR_INTERPRETED_TYPE_INT8:
		  break;
		case SAHPI_SENSOR_INTERPRETED_TYPE_BUFFER:
		  break;
		}
	      memcpy (ctx->saHpiEventSensorTriggerThresholdInterpreted,
		      &reading.Interpreted.Value, SAHPI_SENSOR_BUFFER_LENGTH);
	      ctx->saHpiEventSensorTriggerThresholdInterpreted_len =
		EVENT_TRIGGER_THRESHOLD_INTERPRETED_MAX;
	    }
	  if (reading.ValuesPresent & SAHPI_SRF_EVENT_STATE)
	    {
	      ctx->saHpiEventSensorTriggerThresholdEventState[0] =
		reading.EventStatus.SensorStatus;
	      reading.EventStatus.SensorStatus =
		htons (reading.EventStatus.EventStatus);
	      memcpy (ctx->saHpiEventSensorTriggerThresholdEventState + 1,
		      &reading.EventStatus.EventStatus, 2);
	      ctx->saHpiEventSensorTriggerThresholdEventState_len =
		EVENT_TRIGGER_THRESHOLD_EVENT_STATE_MAX;

	    }

	  ctx->saHpiEventSensorPreviousState = sensor.PreviousState;
	  ctx->saHpiEventSensorOem = sensor.Oem;
	  ctx->saHpiEventSensorSpecific = sensor.SensorSpecific;



	  // Update the var  pointer references.

	  saHpiSensorNotification[NOTIF_EVENTINDEX].value =
	    (u_char *) & ctx->saHpiEventIndex;
	  saHpiSensorNotification[NOTIF_EVENTINDEX].value_len =
	    sizeof (ctx->saHpiEventIndex);

	  saHpiSensorNotification[NOTIF_SEVERITY].value =
	    (u_char *) & ctx->saHpiEventSeverity;
	  saHpiSensorNotification[NOTIF_SEVERITY].value_len =
	    sizeof (ctx->saHpiEventSeverity);

	  saHpiSensorNotification[SENSOR_NOTIF_SENSORCATEGORY].value =
	    (u_char *) & ctx->saHpiEventSensorCategory;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSORCATEGORY].value_len =
	    sizeof (ctx->saHpiEventSensorCategory);
	  saHpiSensorNotification[SENSOR_NOTIF_SENSORNUM].value =
	    (u_char *) & ctx->saHpiEventSensorNum;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSORNUM].value_len =
	    sizeof (ctx->saHpiEventSensorNum);

	  saHpiSensorNotification[SENSOR_NOTIF_SENSORTYPE].value =
	    (u_char *) & ctx->saHpiEventSensorType;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSORTYPE].value_len =
	    sizeof (ctx->saHpiEventSensorType);

	  saHpiSensorNotification[SENSOR_NOTIF_SENSOROPTIONALDATA].value =
	    (u_char *) & ctx->saHpiEventSensorOptionalData;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSOROPTIONALDATA].value_len =
	    sizeof (ctx->saHpiEventSensorOptionalData);


	  saHpiSensorNotification[SENSOR_NOTIF_SENSORTRIGGERREADINGRAW].
	    value = (u_char *) & ctx->saHpiEventSensorTriggerReadingRaw;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSORTRIGGERREADINGRAW].
	    value_len = sizeof (ctx->saHpiEventSensorTriggerReadingRaw);

	  saHpiSensorNotification[SENSOR_NOTIF_SENSOROEM].value =
	    (u_char *) & ctx->saHpiEventSensorOem;
	  saHpiSensorNotification[SENSOR_NOTIF_SENSOROEM].value_len =
	    sizeof (ctx->saHpiEventSensorOem);

	  // Point *var to this trap_vars. 
	  *var = (trap_vars *) & saHpiSensorNotification;
	  *var_len = SENSOR_NOTIF_COUNT;
	  *var_trap_oid = (oid *) & saHpiSensorNotification_oid;

	  // Update the Sensor table with new information
	  // No need
	}

      if (event_entry->EventType == SAHPI_ET_HOTSWAP)
	{
	  hotswap = event_entry->EventDataUnion.HotSwapEvent;
	  // CR: #022
	  ctx->saHpiEventHotSwapState = hotswap.HotSwapState + 1;
	  ctx->saHpiEventPreviousHotSwapState =
	    hotswap.PreviousHotSwapState + 1;


	  saHpiHotSwapNotification[NOTIF_EVENTINDEX].value =
	    (u_char *) & ctx->saHpiEventIndex;
	  saHpiHotSwapNotification[NOTIF_EVENTINDEX].value_len =
	    sizeof (ctx->saHpiEventIndex);

	  saHpiHotSwapNotification[NOTIF_SEVERITY].value =
	    (u_char *) & ctx->saHpiEventSeverity;
	  saHpiHotSwapNotification[NOTIF_SEVERITY].value_len =
	    sizeof (ctx->saHpiEventSeverity);

	  saHpiHotSwapNotification[HOTSWAP_STATE].value =
	    (u_char *) & ctx->saHpiEventHotSwapState;

	  saHpiHotSwapNotification[HOTSWAP_STATE].value_len =
	    sizeof (ctx->saHpiEventHotSwapState);

	  saHpiHotSwapNotification[HOTSWAP_PREVIOUS_STATE].value =
	    (u_char *) & ctx->saHpiEventPreviousHotSwapState;

	  saHpiHotSwapNotification[HOTSWAP_PREVIOUS_STATE].value_len =
	    sizeof (ctx->saHpiEventPreviousHotSwapState);

	  // Point *var to this trap_vars. 
	  *var = (trap_vars *) & saHpiHotSwapNotification;
	  *var_len = HOTSWAP_NOTIF_COUNT;
	  *var_trap_oid = saHpiHotSwapNotification_oid;
	  // Notify the HotSwap table about the event state
	  update_hotswap_event (rpt_entry->DomainId,
				rpt_entry->ResourceId, &hotswap);

	}

      if (event_entry->EventType == SAHPI_ET_WATCHDOG)
	{
	  watchdog = event_entry->EventDataUnion.WatchdogEvent;
	  ctx->saHpiEventWatchdogNum = watchdog.WatchdogNum;
	  ctx->saHpiEventWatchdogAction = watchdog.WatchdogAction + 1;
	  ctx->saHpiEventWatchdogPreTimerAction =
	    watchdog.WatchdogPreTimerAction + 1;
	  ctx->saHpiEventWatchdogUse = watchdog.WatchdogUse + 1;

	  saHpiWatchdogNotification[WATCHDOG_NOTIF_NUM].value =
	    (u_char *) & ctx->saHpiEventWatchdogNum;
	  saHpiWatchdogNotification[WATCHDOG_NOTIF_NUM].value_len =
	    sizeof (ctx->saHpiEventWatchdogNum);


	  saHpiWatchdogNotification[WATCHDOG_NOTIF_ACTION].value =
	    (u_char *) & ctx->saHpiEventWatchdogAction;
	  saHpiWatchdogNotification[WATCHDOG_NOTIF_ACTION].value_len =
	    sizeof (ctx->saHpiEventWatchdogAction);

	  saHpiWatchdogNotification[WATCHDOG_NOTIF_PRETIMERACTION].value =
	    (u_char *) & ctx->saHpiEventWatchdogPreTimerAction;
	  saHpiWatchdogNotification[WATCHDOG_NOTIF_PRETIMERACTION].value_len =
	    sizeof (ctx->saHpiEventWatchdogPreTimerAction);


	  saHpiWatchdogNotification[WATCHDOG_NOTIF_USE].value =
	    (u_char *) & ctx->saHpiEventWatchdogUse;

	  saHpiWatchdogNotification[WATCHDOG_NOTIF_USE].value_len =
	    sizeof (ctx->saHpiEventWatchdogUse);

	  saHpiWatchdogNotification[NOTIF_EVENTINDEX].value =
	    (u_char *) & ctx->saHpiEventIndex;
	  saHpiWatchdogNotification[NOTIF_EVENTINDEX].value_len =
	    sizeof (ctx->saHpiEventIndex);

	  saHpiWatchdogNotification[NOTIF_SEVERITY].value =
	    (u_char *) & ctx->saHpiEventSeverity;
	  saHpiWatchdogNotification[NOTIF_SEVERITY].value_len =
	    sizeof (ctx->saHpiEventSeverity);


	  // Point *var to this trap_vars. 
	  *var = (trap_vars *) & saHpiWatchdogNotification;
	  *var_len = WATCHDOG_NOTIF_COUNT;
	  *var_trap_oid = saHpiWatchdogNotification_oid;

	  // Update the Watchdog table
	  update_watchdog_row (rpt_entry->DomainId,
			       rpt_entry->ResourceId,
			       watchdog.WatchdogNum, &watchdog);
	}

      if (event_entry->EventType == SAHPI_ET_OEM)
	{
	  oem = event_entry->EventDataUnion.OemEvent;
	  ctx->saHpiEventOemManufacturerIdT = oem.MId;
	  memcpy (ctx->saHpiEventOemEventData,
		  oem.OemEventData, SAHPI_OEM_EVENT_DATA_SIZE);
	  ctx->saHpiEventOemEventData_len = SAHPI_OEM_EVENT_DATA_SIZE;

	  saHpiOEMNotification[OEM_NOTIF_EVENT_DATA].value =
	    (u_char *) & ctx->saHpiEventOemEventData;
	  saHpiOEMNotification[OEM_NOTIF_EVENT_DATA].value_len =
	    ctx->saHpiEventOemEventData_len;

	  saHpiOEMNotification[NOTIF_EVENTINDEX].value =
	    (u_char *) & ctx->saHpiEventIndex;
	  saHpiOEMNotification[NOTIF_EVENTINDEX].value_len =
	    sizeof (ctx->saHpiEventIndex);

	  saHpiOEMNotification[NOTIF_SEVERITY].value =
	    (u_char *) & ctx->saHpiEventSeverity;
	  saHpiOEMNotification[NOTIF_SEVERITY].value_len =
	    sizeof (ctx->saHpiEventSeverity);


	  // Point *var to this trap_vars. 
	  *var = (trap_vars *) & saHpiOEMNotification;
	  *var_len = OEM_NOTIF_COUNT;
	  *var_trap_oid = saHpiOEMNotification_oid;


	}

      if (event_entry->EventType == SAHPI_ET_USER)
	{
	  user = event_entry->EventDataUnion.UserEvent;
	  memcpy (ctx->saHpiEventUserEventData,
		  user.UserEventData, SAHPI_USER_EVENT_DATA_SIZE);
	  ctx->saHpiEventUserEventData_len = SAHPI_USER_EVENT_DATA_SIZE;


	  saHpiUserNotification[USER_NOTIF_EVENT_DATA].value =
	    (u_char *) & ctx->saHpiEventUserEventData;
	  saHpiUserNotification[USER_NOTIF_EVENT_DATA].value_len =
	    ctx->saHpiEventUserEventData_len;

	  saHpiUserNotification[NOTIF_EVENTINDEX].value =
	    (u_char *) & ctx->saHpiEventIndex;
	  saHpiUserNotification[NOTIF_EVENTINDEX].value_len =
	    sizeof (ctx->saHpiEventIndex);

	  saHpiUserNotification[NOTIF_SEVERITY].value =
	    (u_char *) & ctx->saHpiEventSeverity;
	  saHpiUserNotification[NOTIF_SEVERITY].value_len =
	    sizeof (ctx->saHpiEventSeverity);


	  // Point *var to this trap_vars. 
	  *var = (trap_vars *) & saHpiUserNotification;
	  *var_len = USER_NOTIF_COUNT;
	  *var_trap_oid = saHpiUserNotification_oid;

	}
      if (update_entry == MIB_TRUE)
	      return AGENT_ENTRY_EXIST;
      return AGENT_NEW_ENTRY;
    }
  return AGENT_ERR_NULL_DATA;
}




int
delete_event_row (SaHpiDomainIdT domain_id,
		  SaHpiResourceIdT resource_id, unsigned long num)
{
  saHpiEventTable_context *ctx;
  int rc = AGENT_ERR_NOT_FOUND;
  netsnmp_index event_index;
  oid event_oid[EVENT_INDEX_NR];

  DEBUGMSGTL ((AGENT, "delete_event_row(%d, %d, %d). Entry \n",
	       domain_id, resource_id, num));

  event_oid[0] = domain_id;
  event_oid[1] = resource_id;
  event_oid[2] = num;

  event_index.oids = (oid *) & event_oid;
  event_index.len = EVENT_INDEX_NR;

  ctx = CONTAINER_FIND (cb.container, &event_index);

  if (ctx)
    {
      CONTAINER_REMOVE (cb.container, ctx);
      saHpiEventTable_delete_row (ctx);
      event_count = CONTAINER_SIZE (cb.container);
      rc = AGENT_ERR_NOERROR;
    }
  DEBUGMSGTL ((AGENT, "delete_event_row. Exit (rc: %d).\n", rc));
  return rc;
}




/************************************************************
 * the *_row_copy routine
 */
static int
saHpiEventTable_row_copy (saHpiEventTable_context * dst,
			  saHpiEventTable_context * src)
{
  if (!dst || !src)
    return 1;

  /*
   * copy index, if provided
   */
  if (dst->index.oids)
    free (dst->index.oids);
  if (snmp_clone_mem ((void *) &dst->index.oids, src->index.oids,
		      src->index.len * sizeof (oid)))
    {
      dst->index.oids = NULL;
      return 1;
    }
  dst->index.len = src->index.len;


  dst->saHpiEventIndex = src->saHpiEventIndex;

  dst->saHpiEventType = src->saHpiEventType;

  dst->saHpiEventTimestamp = src->saHpiEventTimestamp;

  dst->saHpiEventSeverity = src->saHpiEventSeverity;

  dst->saHpiEventSensorNum = src->saHpiEventSensorNum;

  dst->saHpiEventSensorType = src->saHpiEventSensorType;

  dst->saHpiEventSensorCategory = src->saHpiEventSensorCategory;

  dst->saHpiEventSensorAssertion = src->saHpiEventSensorAssertion;

  dst->saHpiEventSensorStateCategoryUnspecified =
    src->saHpiEventSensorStateCategoryUnspecified;

  dst->saHpiEventSensorStateCategoryThreshold =
    src->saHpiEventSensorStateCategoryThreshold;

  dst->saHpiEventSensorStateCategoryUsage =
    src->saHpiEventSensorStateCategoryUsage;

  dst->saHpiEventSensorStateCategoryState =
    src->saHpiEventSensorStateCategoryState;

  dst->saHpiEventSensorStateCategoryPredFail =
    src->saHpiEventSensorStateCategoryPredFail;

  dst->saHpiEventSensorStateCategoryLimit =
    src->saHpiEventSensorStateCategoryLimit;

  dst->saHpiEventSensorStateCategoryPerformance =
    src->saHpiEventSensorStateCategoryPerformance;

  dst->saHpiEventSensorStateCategorySeverity =
    src->saHpiEventSensorStateCategorySeverity;

  dst->saHpiEventSensorStateCategoryPresence =
    src->saHpiEventSensorStateCategoryPresence;

  dst->saHpiEventSensorStateCategoryEnable =
    src->saHpiEventSensorStateCategoryEnable;

  dst->saHpiEventSensorStateCategoryAvailability =
    src->saHpiEventSensorStateCategoryAvailability;

  dst->saHpiEventSensorStateCategoryRedundancy =
    src->saHpiEventSensorStateCategoryRedundancy;

  dst->saHpiEventSensorStateCategoryUser =
    src->saHpiEventSensorStateCategoryUser;

  dst->saHpiEventSensorStateCategoryGeneric =
    src->saHpiEventSensorStateCategoryGeneric;

  dst->saHpiEventSensorOptionalData = src->saHpiEventSensorOptionalData;

  dst->saHpiEventSensorTriggerReadingType =
    src->saHpiEventSensorTriggerReadingType;

  dst->saHpiEventSensorTriggerReadingRaw =
    src->saHpiEventSensorTriggerReadingRaw;

  dst->saHpiEventSensorTriggerReadingInterpretedType =
    src->saHpiEventSensorTriggerReadingInterpretedType;

  memcpy (dst->saHpiEventSensorTriggerReadingInterpreted,
	  src->saHpiEventSensorTriggerReadingInterpreted,
	  src->saHpiEventSensorTriggerReadingInterpreted_len);
  dst->saHpiEventSensorTriggerReadingInterpreted_len =
    src->saHpiEventSensorTriggerReadingInterpreted_len;

  memcpy (dst->saHpiEventSensorTriggerReadingEventState,
	  src->saHpiEventSensorTriggerReadingEventState,
	  src->saHpiEventSensorTriggerReadingEventState_len);
  dst->saHpiEventSensorTriggerReadingEventState_len =
    src->saHpiEventSensorTriggerReadingEventState_len;

  dst->saHpiEventSensorTriggerThresholdType =
    src->saHpiEventSensorTriggerThresholdType;

  dst->saHpiEventSensorTriggerThresholdRaw =
    src->saHpiEventSensorTriggerThresholdRaw;

  dst->saHpiEventSensorTriggerThresholdInterpretedType =
    src->saHpiEventSensorTriggerThresholdInterpretedType;

  memcpy (dst->saHpiEventSensorTriggerThresholdInterpreted,
	  src->saHpiEventSensorTriggerThresholdInterpreted,
	  src->saHpiEventSensorTriggerThresholdInterpreted_len);
  dst->saHpiEventSensorTriggerThresholdInterpreted_len =
    src->saHpiEventSensorTriggerThresholdInterpreted_len;

  memcpy (dst->saHpiEventSensorTriggerThresholdEventState,
	  src->saHpiEventSensorTriggerThresholdEventState,
	  src->saHpiEventSensorTriggerThresholdEventState_len);
  dst->saHpiEventSensorTriggerThresholdEventState_len =
    src->saHpiEventSensorTriggerThresholdEventState_len;

  dst->saHpiEventSensorPreviousState = src->saHpiEventSensorPreviousState;

  dst->saHpiEventSensorOem = src->saHpiEventSensorOem;

  dst->saHpiEventSensorSpecific = src->saHpiEventSensorSpecific;

  dst->saHpiEventHotSwapState = src->saHpiEventHotSwapState;

  dst->saHpiEventPreviousHotSwapState = src->saHpiEventPreviousHotSwapState;

  dst->saHpiEventWatchdogNum = src->saHpiEventWatchdogNum;

  dst->saHpiEventWatchdogAction = src->saHpiEventWatchdogAction;

  dst->saHpiEventWatchdogPreTimerAction =
    src->saHpiEventWatchdogPreTimerAction;

  dst->saHpiEventWatchdogUse = src->saHpiEventWatchdogUse;

  dst->saHpiEventOemManufacturerIdT = src->saHpiEventOemManufacturerIdT;

  memcpy (dst->saHpiEventOemEventData, src->saHpiEventOemEventData,
	  src->saHpiEventOemEventData_len);
  dst->saHpiEventOemEventData_len = src->saHpiEventOemEventData_len;

  memcpy (dst->saHpiEventUserEventData, src->saHpiEventUserEventData,
	  src->saHpiEventUserEventData_len);
  dst->saHpiEventUserEventData_len = src->saHpiEventUserEventData_len;

  dst->saHpiEventDelete = src->saHpiEventDelete;

  dst->resource_id = src->resource_id;
  dst->domain_id = src->domain_id;
  return 0;
}


/*
 * the *_extract_index routine
 */
int
saHpiEventTable_extract_index (saHpiEventTable_context * ctx,
			       netsnmp_index * hdr)
{
  /*
   * temporary local storage for extracting oid index
   */
  netsnmp_variable_list var_saHpiDomainID;
  netsnmp_variable_list var_saHpiResourceID;
  netsnmp_variable_list var_saHpiEntryID;
  int err;

  /*
   * copy index, if provided
   */
  if (hdr)
    {
      netsnmp_assert (ctx->index.oids == NULL);
      if (snmp_clone_mem ((void *) &ctx->index.oids, hdr->oids,
			  hdr->len * sizeof (oid)))
	{
	  return -1;
	}
      ctx->index.len = hdr->len;
    }


  memset (&var_saHpiDomainID, 0x00, sizeof (var_saHpiDomainID));
  var_saHpiDomainID.type = ASN_UNSIGNED;
  var_saHpiDomainID.next_variable = &var_saHpiResourceID;


  memset (&var_saHpiResourceID, 0x00, sizeof (var_saHpiResourceID));
  var_saHpiResourceID.type = ASN_UNSIGNED;
  var_saHpiResourceID.next_variable = &var_saHpiEntryID;

  memset (&var_saHpiEntryID, 0x00, sizeof (var_saHpiEntryID));
  var_saHpiEntryID.type = ASN_UNSIGNED;
  var_saHpiEntryID.next_variable = NULL;


  /*
   * parse the oid into the individual components
   */
  err = parse_oid_indexes (hdr->oids, hdr->len, &var_saHpiDomainID);
  if (err == SNMP_ERR_NOERROR)
    {
      /*
       * copy components into the context structure
       */
	      /** skipping external index saHpiDomainID */

	      /** skipping external index saHpiResourceID */

	      /** skipping external index saHpiEntryID */
      ctx->saHpiEventIndex = *var_saHpiEntryID.val.integer;


    }

  /*
   * parsing may have allocated memory. free it.
   */
  snmp_reset_var_buffers (&var_saHpiDomainID);

  return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int
saHpiEventTable_can_delete (saHpiEventTable_context * undo_ctx,
			    saHpiEventTable_context * row_ctx,
			    netsnmp_request_group * rg)
{


  return 1;
}


/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated saHpiEventTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
saHpiEventTable_context *
saHpiEventTable_create_row (netsnmp_index * hdr)
{
  saHpiEventTable_context *ctx =
    SNMP_MALLOC_TYPEDEF (saHpiEventTable_context);
  if (!ctx)
    return NULL;


  if (saHpiEventTable_extract_index (ctx, hdr))
    {
      free (ctx->index.oids);
      free (ctx);
      return NULL;
    }

  ctx->hash = 0;
  ctx->saHpiEventDelete = SNMP_ROW_ACTIVE;

  return ctx;
}


/************************************************************
 * the *_duplicate row routine
 */
saHpiEventTable_context *
saHpiEventTable_duplicate_row (saHpiEventTable_context * row_ctx)
{
  saHpiEventTable_context *dup;

  if (!row_ctx)
    return NULL;

  dup = SNMP_MALLOC_TYPEDEF (saHpiEventTable_context);
  if (!dup)
    return NULL;

  if (saHpiEventTable_row_copy (dup, row_ctx))
    {
      free (dup);
      dup = NULL;
    }

  return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index *
saHpiEventTable_delete_row (saHpiEventTable_context * ctx)
{

  if (ctx->index.oids)
    free (ctx->index.oids);


  free (ctx);

  return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void
saHpiEventTable_set_reserve1 (netsnmp_request_group * rg)
{
  saHpiEventTable_context *row_ctx =
    (saHpiEventTable_context *) rg->existing_row;



  netsnmp_variable_list *var;
  netsnmp_request_group_item *current;

  int rc = SNMP_ERR_NOERROR;

  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_reserve1: Entry.\n"));

  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIEVENTTYPE:
	case COLUMN_SAHPIEVENTTIMESTAMP:
	case COLUMN_SAHPIEVENTSEVERITY:
	case COLUMN_SAHPIEVENTSENSORNUM:
	case COLUMN_SAHPIEVENTSENSORTYPE:
	case COLUMN_SAHPIEVENTSENSORCATEGORY:
	case COLUMN_SAHPIEVENTSENSORASSERTION:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUNSPECIFIED:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYTHRESHOLD:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUSAGE:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYSTATE:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPREDFAIL:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYLIMIT:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPERFORMANCE:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYSEVERITY:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPRESENCE:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYENABLE:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYAVAILABILITY:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYREDUNDANCY:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUSER:
	case COLUMN_SAHPIEVENTSENSORSTATECATEGORYGENERIC:
	case COLUMN_SAHPIEVENTSENSOROPTIONALDATA:
	case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGTYPE:
	case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGRAW:
	case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGINTERPRETEDTYPE:
	case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGINTERPRETED:
	case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGEVENTSTATE:
	case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDTYPE:
	case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDRAW:
	case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDINTERPRETEDTYPE:
	case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDINTERPRETED:
	case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDEVENTSTATE:
	case COLUMN_SAHPIEVENTSENSORPREVIOUSSTATE:
	case COLUMN_SAHPIEVENTSENSOROEM:
	case COLUMN_SAHPIEVENTSENSORSPECIFIC:
	case COLUMN_SAHPIEVENTHOTSWAPSTATE:
	case COLUMN_SAHPIEVENTPREVIOUSHOTSWAPSTATE:
	case COLUMN_SAHPIEVENTWATCHDOGNUM:
	case COLUMN_SAHPIEVENTWATCHDOGACTION:
	case COLUMN_SAHPIEVENTWATCHDOGPRETIMERACTION:
	case COLUMN_SAHPIEVENTWATCHDOGUSE:
	case COLUMN_SAHPIEVENTOEMMANUFACTURERIDT:
	case COLUMN_SAHPIEVENTOEMEVENTDATA:
	  rc = SNMP_ERR_NOTWRITABLE;
	  break;

	case COLUMN_SAHPIEVENTDELETE:
	    /** TruthValue = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiEventDelete));
	  break;


	default:
		/** We shouldn't get here */
	  rc = SNMP_ERR_GENERR;
	  snmp_log (LOG_ERR, "unknown column in "
		    "saHpiEventTable_set_reserve1\n");
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
      rg->status = SNMP_MAX (rg->status, current->ri->status);
    }

  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_reserve1: Exit (rc: %d).\n", rc));

}

void
saHpiEventTable_set_reserve2 (netsnmp_request_group * rg)
{
  saHpiEventTable_context *undo_ctx =
    (saHpiEventTable_context *) rg->undo_info;

  netsnmp_request_group_item *current;
  netsnmp_variable_list *var;
  int rc = SNMP_ERR_NOERROR;

  rg->rg_void = rg->list->ri;


  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_reserve2. Entry.\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIEVENTDELETE:
	    /** RowStatus = ASN_INTEGER */
	  rc = netsnmp_check_vb_rowstatus (var,
					   undo_ctx ? undo_ctx->
					   saHpiEventDelete : 0);
	  break;

	default:
		/** We shouldn't get here */
	  netsnmp_assert (0);  /** why wasn't this caught in reserve1? */
	  break;
	}

      if (rc)
	{
	  netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
	}
    }

  for (current = rg->list; current; current = current->next)
    {

      // We check to see if the row exist by finding the
      // 'hash' variable. If its set to '0' - we know we have
      // not manipulated it and thus its a non-existent row

      if (((saHpiEventTable_context *) rg->existing_row)->hash == 0)
	{
	  //rc =  SNMP_ERR_NOSUCHNAME;
	  var = current->ri->requestvb;

	  // SNMPv2-TC has a diagram of actions.
	  if ((*var->val.integer == SNMP_ROW_CREATEANDGO)	// createAndGo(4)
	      || (*var->val.integer == SNMP_ROW_ACTIVE)	// active (1)
	      || (*var->val.integer == SNMP_ROW_NOTINSERVICE))	// notInService(2)
	    rc = SNMP_ERR_INCONSISTENTVALUE;
	  if (*var->val.integer == SNMP_ROW_NOTREADY)	// notReady(3)
	    rc = SNMP_ERR_INCONSISTENTNAME;
	  if (*var->val.integer == SNMP_ROW_CREATEANDWAIT)	// createAndWait(5)
	    rc = SNMP_ERR_WRONGVALUE;

	  // This 'destroy' should work on _ANY_ row (even
	  // non-existent ones.  Refer to SNMPv2-TC RFC
	  //if (*var->val.integer == SNMP_ROW_DESTROY) // destory(6)
	  //  rc = SNMP_ERR_INCONSISTENTNAME;

	  if (rc)
	    netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
	}
    }
  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_reserve2. Exit (rc: %d).\n", rc));
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void
saHpiEventTable_set_action (netsnmp_request_group * rg)
{


  netsnmp_request_group_item *current;
  netsnmp_variable_list *var;

  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_action. Entry.\n"));
  for (current = rg->list; current; current = current->next)
    {


      var = current->ri->requestvb;

      if ((*var->val.integer == SNMP_ROW_DESTROY))
	{
	  /*
	     No need for that.

	     if (row_ctx->hash != 0)
	     delete_event_row(row_ctx->domain_id,
	     row_ctx->resource_id,
	     row_ctx->saHpiEventIndex);
	   */

	  rg->row_deleted = 1;
	}
      else			// The rest of SNMP_ROW operations (4,5)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri,
					SNMP_ERR_INCONSISTENTVALUE);
    }
  DEBUGMSGTL ((AGENT, "saHpiEventTable_set_action. Entry.\n"));
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void
saHpiEventTable_set_commit (netsnmp_request_group * rg)
{

}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void
saHpiEventTable_set_free (netsnmp_request_group * rg)
{

}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void
saHpiEventTable_set_undo (netsnmp_request_group * rg)
{

}

/************************************************************
 *
 * Initialize the saHpiEventTable table by defining its contents and how it's structured
 */
void
initialize_table_saHpiEventTable (void)
{
  netsnmp_table_registration_info *table_info;

  if (my_handler)
    {
      snmp_log (LOG_ERR,
		"initialize_table_saHpiEventTable_handler called again\n");
      return;
    }

  memset (&cb, 0x00, sizeof (cb));

    /** create the table structure itself */
  table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);

  /*
   * if your table is read only, it's easiest to change the
   * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
   */
  my_handler = netsnmp_create_handler_registration ("saHpiEventTable",
						    netsnmp_table_array_helper_handler,
						    saHpiEventTable_oid,
						    saHpiEventTable_oid_len,
						    HANDLER_CAN_RWRITE);

  if (!my_handler || !table_info)
    {
      snmp_log (LOG_ERR, "malloc failed in "
		"initialize_table_saHpiEventTable_handler\n");
      return;	/** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */

  /*
   * internal indexes
   */
	/** index: saHpiDomainID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
	/** index: saHpiResourceID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
	/** index: saHpiEntryID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);

  table_info->min_column = saHpiEventTable_COL_MIN;
  table_info->max_column = saHpiEventTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
  cb.get_value = saHpiEventTable_get_value;
  cb.container = netsnmp_container_find ("saHpiEventTable_primary:"
					 "saHpiEventTable:"
					 "table_container");



  cb.create_row = (UserRowMethod *) saHpiEventTable_create_row;

  cb.duplicate_row = (UserRowMethod *) saHpiEventTable_duplicate_row;
  cb.delete_row = (UserRowMethod *) saHpiEventTable_delete_row;
  cb.row_copy = (Netsnmp_User_Row_Operation *) saHpiEventTable_row_copy;

  cb.can_delete = (Netsnmp_User_Row_Action *) saHpiEventTable_can_delete;

  cb.set_reserve1 = saHpiEventTable_set_reserve1;
  cb.set_reserve2 = saHpiEventTable_set_reserve2;
  cb.set_action = saHpiEventTable_set_action;
  cb.set_commit = saHpiEventTable_set_commit;
  cb.set_free = saHpiEventTable_set_free;
  cb.set_undo = saHpiEventTable_set_undo;


  DEBUGMSGTL (("initialize_table_saHpiEventTable",
	       "Registering table saHpiEventTable " "as a table array\n"));
  netsnmp_table_container_register (my_handler, table_info, &cb,
				    cb.container, 1);

  netsnmp_register_read_only_instance (netsnmp_create_handler_registration
				       ("event_count_entries",
					event_count_entries_handler,
					saHpiEventCount_oid,
					OID_LENGTH (saHpiEventCount_oid),
					HANDLER_CAN_RONLY));

}

/************************************************************
 * saHpiEventTable_get_value
 */
int
saHpiEventTable_get_value (netsnmp_request_info * request,
			   netsnmp_index * item,
			   netsnmp_table_request_info * table_info)
{
  netsnmp_variable_list *var = request->requestvb;
  saHpiEventTable_context *context = (saHpiEventTable_context *) item;

  switch (table_info->colnum)
    {

    case COLUMN_SAHPIEVENTINDEX:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiEventIndex,
				sizeof (context->saHpiEventIndex));
      break;

    case COLUMN_SAHPIEVENTTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventType,
				sizeof (context->saHpiEventType));
      break;

    case COLUMN_SAHPIEVENTTIMESTAMP:
	    /** HpiTimeStamp = ASN_COUNTER64 */
      snmp_set_var_typed_value (var, ASN_COUNTER64,
				(char *) &context->saHpiEventTimestamp,
				sizeof (context->saHpiEventTimestamp));
      break;

    case COLUMN_SAHPIEVENTSEVERITY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventSeverity,
				sizeof (context->saHpiEventSeverity));
      break;

    case COLUMN_SAHPIEVENTSENSORNUM:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiEventSensorNum,
				sizeof (context->saHpiEventSensorNum));
      break;

    case COLUMN_SAHPIEVENTSENSORTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventSensorType,
				sizeof (context->saHpiEventSensorType));
      break;

    case COLUMN_SAHPIEVENTSENSORCATEGORY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorCategory,
				sizeof (context->saHpiEventSensorCategory));
      break;

    case COLUMN_SAHPIEVENTSENSORASSERTION:
	    /** TruthValue = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorAssertion,
				sizeof (context->saHpiEventSensorAssertion));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUNSPECIFIED:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryUnspecified,
				sizeof (context->
					saHpiEventSensorStateCategoryUnspecified));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYTHRESHOLD:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryThreshold,
				sizeof (context->
					saHpiEventSensorStateCategoryThreshold));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUSAGE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryUsage,
				sizeof (context->
					saHpiEventSensorStateCategoryUsage));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYSTATE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryState,
				sizeof (context->
					saHpiEventSensorStateCategoryState));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPREDFAIL:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryPredFail,
				sizeof (context->
					saHpiEventSensorStateCategoryPredFail));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYLIMIT:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryLimit,
				sizeof (context->
					saHpiEventSensorStateCategoryLimit));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPERFORMANCE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryPerformance,
				sizeof (context->
					saHpiEventSensorStateCategoryPerformance));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYSEVERITY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategorySeverity,
				sizeof (context->
					saHpiEventSensorStateCategorySeverity));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYPRESENCE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryPresence,
				sizeof (context->
					saHpiEventSensorStateCategoryPresence));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYENABLE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryEnable,
				sizeof (context->
					saHpiEventSensorStateCategoryEnable));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYAVAILABILITY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryAvailability,
				sizeof (context->
					saHpiEventSensorStateCategoryAvailability));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYREDUNDANCY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryRedundancy,
				sizeof (context->
					saHpiEventSensorStateCategoryRedundancy));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYUSER:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryUser,
				sizeof (context->
					saHpiEventSensorStateCategoryUser));
      break;

    case COLUMN_SAHPIEVENTSENSORSTATECATEGORYGENERIC:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorStateCategoryGeneric,
				sizeof (context->
					saHpiEventSensorStateCategoryGeneric));
      break;

    case COLUMN_SAHPIEVENTSENSOROPTIONALDATA:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorOptionalData,
				sizeof (context->
					saHpiEventSensorOptionalData));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGTYPE:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorTriggerReadingType,
				sizeof (context->
					saHpiEventSensorTriggerReadingType));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGRAW:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorTriggerReadingRaw,
				sizeof (context->
					saHpiEventSensorTriggerReadingRaw));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGINTERPRETEDTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorTriggerReadingInterpretedType,
				sizeof (context->
					saHpiEventSensorTriggerReadingInterpretedType));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGINTERPRETED:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiEventSensorTriggerReadingInterpreted,
				context->
				saHpiEventSensorTriggerReadingInterpreted_len);
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERREADINGEVENTSTATE:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiEventSensorTriggerReadingEventState,
				context->
				saHpiEventSensorTriggerReadingEventState_len);
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDTYPE:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorTriggerThresholdType,
				sizeof (context->
					saHpiEventSensorTriggerThresholdType));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDRAW:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorTriggerThresholdRaw,
				sizeof (context->
					saHpiEventSensorTriggerThresholdRaw));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDINTERPRETEDTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventSensorTriggerThresholdInterpretedType,
				sizeof (context->
					saHpiEventSensorTriggerThresholdInterpretedType));
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDINTERPRETED:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiEventSensorTriggerThresholdInterpreted,
				context->
				saHpiEventSensorTriggerThresholdInterpreted_len);
      break;

    case COLUMN_SAHPIEVENTSENSORTRIGGERTHRESHOLDEVENTSTATE:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiEventSensorTriggerThresholdEventState,
				context->
				saHpiEventSensorTriggerThresholdEventState_len);
      break;

    case COLUMN_SAHPIEVENTSENSORPREVIOUSSTATE:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorPreviousState,
				sizeof (context->
					saHpiEventSensorPreviousState));
      break;

    case COLUMN_SAHPIEVENTSENSOROEM:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiEventSensorOem,
				sizeof (context->saHpiEventSensorOem));
      break;

    case COLUMN_SAHPIEVENTSENSORSPECIFIC:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventSensorSpecific,
				sizeof (context->saHpiEventSensorSpecific));
      break;

    case COLUMN_SAHPIEVENTHOTSWAPSTATE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventHotSwapState,
				sizeof (context->saHpiEventHotSwapState));
      break;

    case COLUMN_SAHPIEVENTPREVIOUSHOTSWAPSTATE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventPreviousHotSwapState,
				sizeof (context->
					saHpiEventPreviousHotSwapState));
      break;

    case COLUMN_SAHPIEVENTWATCHDOGNUM:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiEventWatchdogNum,
				sizeof (context->saHpiEventWatchdogNum));
      break;

    case COLUMN_SAHPIEVENTWATCHDOGACTION:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventWatchdogAction,
				sizeof (context->saHpiEventWatchdogAction));
      break;

    case COLUMN_SAHPIEVENTWATCHDOGPRETIMERACTION:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiEventWatchdogPreTimerAction,
				sizeof (context->
					saHpiEventWatchdogPreTimerAction));
      break;

    case COLUMN_SAHPIEVENTWATCHDOGUSE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventWatchdogUse,
				sizeof (context->saHpiEventWatchdogUse));
      break;

    case COLUMN_SAHPIEVENTOEMMANUFACTURERIDT:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiEventOemManufacturerIdT,
				sizeof (context->
					saHpiEventOemManufacturerIdT));
      break;

    case COLUMN_SAHPIEVENTOEMEVENTDATA:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->saHpiEventOemEventData,
				context->saHpiEventOemEventData_len);
      break;

    case COLUMN_SAHPIEVENTUSEREVENTDATA:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiEventUserEventData,
				context->saHpiEventUserEventData_len);
      break;

    case COLUMN_SAHPIEVENTDELETE:
	    /** RowStatus = ASN_INTEGER */
      /*
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventDelete,
				sizeof (context->saHpiEventDelete));
	*/
      return SNMP_ERR_GENERR;
      break;

    default:
	    /** We shouldn't get here */
      snmp_log (LOG_ERR, "unknown column in " "saHpiEventTable_get_value\n");
      return SNMP_ERR_GENERR;
    }
  return SNMP_ERR_NOERROR;
}


int
event_count_entries_handler (netsnmp_mib_handler * handler,
			     netsnmp_handler_registration * reginfo,
			     netsnmp_agent_request_info * reqinfo,
			     netsnmp_request_info * requests)
{

  event_count = CONTAINER_SIZE (cb.container);

  if (reqinfo->mode == MODE_GET)
    snmp_set_var_typed_value (requests->requestvb, ASN_COUNTER,
			      (u_char *) & event_count, sizeof (event_count));

  return SNMP_ERR_NOERROR;
}
