/*
 * (C) Copyright IBM Corp. 2003
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Authors:
 *   Konrad Rzeszutek <konradr@us.ibm.com>
 *
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id$
 *
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>
#include <netinet/in.h>
#include <saHpiSensorTable.h>

#include <hpiSubagent.h>
#include <SaHpi.h>

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;


extern int send_traps_on_startup;

oid             saHpiSensorTable_oid[] = { saHpiSensorTable_TABLE_OID };
size_t          saHpiSensorTable_oid_len = OID_LENGTH(saHpiSensorTable_oid);

//  { 1, 3, 6, 1, 3, 90, 3, 5, 0 };
oid      saHpiSensorCount_oid[] = { hpiResources_OID, 5, 0 };

//  { 1, 3, 6, 1, 3, 90, 4, 1, 0 }; 
oid      saHpiSensorNotification_oid[] = { hpiNotifications_OID, 1, 0 };

static u_long sensor_count = 0;

#define SENSOR_THD_LOW_MINOR 0
#define SENSOR_THD_LOW_MAJOR 1
#define SENSOR_THD_LOW_CRIT 2
#define SENSOR_THD_UP_MINOR 3
#define SENSOR_THD_UP_MAJOR 4
#define SENSOR_THD_UP_CRIT 5
#define SENSOR_THD_UP_HYSTERESIS 6
#define SENSOR_THD_LOW_HYSTERESIS 7
#define SENSOR_THD_COUNT 8

static sensor_threshold_to_mib sensor_thd[] = {
  {NULL, SAHPI_STM_LOW_MINOR, POS_LOW_MINOR},
  {NULL, SAHPI_STM_LOW_MAJOR, POS_LOW_MAJOR},
  {NULL, SAHPI_STM_LOW_CRIT, POS_LOW_CRITICAL},
  {NULL, SAHPI_STM_UP_MINOR, POS_UP_MINOR},
  {NULL, SAHPI_STM_UP_MAJOR, POS_UP_MAJOR},
  {NULL, SAHPI_STM_UP_CRIT, POS_UP_CRITICAL},
  {NULL, SAHPI_STM_UP_HYSTERESIS, POS_POS_THD_HYSTERESIS},
  {NULL, SAHPI_STM_LOW_HYSTERESIS, POS_NEG_THD_HYSTERESIS}};

#define SIZEOF_UINT32 4
#define SIZEOF_UINT16 2
#define SENSOR_READING_MIN 0
#define SENSOR_READING_MAX 1
#define SENSOR_READING_NORMAL_MIN 2
#define SENSOR_READING_NORMAL_MAX 3
#define SENSOR_READING_NOMINAL 4
#define SENSOR_READING_COUNT 5
/*
 * This is quite location dependent.
 */
static sensor_reading_to_mib sensor_reading[] = {
  {NULL, SAHPI_SRF_MIN, POS_MIN},
  {NULL, SAHPI_SRF_MAX, POS_MAX},
  {NULL, SAHPI_SRF_NORMAL_MIN, POS_MIN_NOM},
  {NULL, SAHPI_SRF_NORMAL_MAX, POS_MAX_NOM},
  {NULL, SAHPI_SRF_NOMINAL, POS_NOMINAL}};


int
populate_sensor(SaHpiSensorRecT *sensor, 
		SaHpiSessionIdT resource_id,
		oid *rdr_entry_oid, size_t rdr_entry_oid_len,
		oid *sensor_oid, size_t *sensor_oid_len) 
{


  int rc = AGENT_ERR_NOERROR;

  oid index_oid[1];
  oid column[2];

  netsnmp_index	sensor_index;
  saHpiSensorTable_context	*sensor_context; 
  SaHpiSensorThresholdsT sensor_threshold;
  SaHpiSessionIdT session_id;
  DEBUGMSGTL((AGENT,"\n\t--- populate_sensor: Entry.\n"));

  if (sensor) {
    sensor_index.len = 1;
    // Look at the MIB to find out what the indexs are
    index_oid[0] = sensor->Num;
    // Possible more indexs?
    sensor_index.oids = (oid *)&index_oid;
    // We are re-populating. Check for existing entries
    sensor_context = NULL;
    sensor_context = CONTAINER_FIND(cb.container, &sensor_index);
    // If we don't find it - we create it.
    if (!sensor_context) {
      // New entry. Add it
      sensor_context = saHpiSensorTable_create_row(&sensor_index);
    } 
    if (!sensor_context) 
      return AGENT_ERR_INTERNAL_ERROR;
	
    // Generate our full OID
    column[0] = 1;
    column[1] =  COLUMN_SAHPISENSORINDEX;
	     
    build_full_oid(saHpiSensorTable_oid, saHpiSensorTable_oid_len,
		       column, 2,
		       &sensor_index,
		       sensor_oid, MAX_OID_LEN, sensor_oid_len);

    // By this stage, sensor_context surely has something in it.
    // '*_modify_context' does a checksum check to see if 
    // the record needs to be altered, and if so populates with
    // information from RDR and the OIDs passed.
    
    // Get Threshold Data

    rc = getSaHpiSession(&session_id);
    if (rc != AGENT_ERR_NOERROR) 
      return rc;
     
    DEBUGMSGTL((AGENT,"Calling SensorThresholdGet\n"));

    rc = saHpiSensorThresholdsGet(session_id,
				  resource_id,
				  sensor->Num,
				  &sensor_threshold);

    DEBUGMSGTL((AGENT,"rc is %d, SA_OK is %d\n", rc, SA_OK));
    DEBUGMSGTL((AGENT,"%x, %x\n", &sensor_threshold, sensor_threshold.LowCritical.Raw));

    if (rc != SA_OK) {
	return AGENT_ERR_OPERATION;
    }

    if (saHpiSensorTable_modify_context(sensor, &sensor_threshold,
					resource_id,
					rdr_entry_oid, rdr_entry_oid_len,
					sensor_context)
	    == AGENT_NEW_ENTRY) {

	  CONTAINER_INSERT(cb.container, sensor_context);	  
	  sensor_count = CONTAINER_SIZE(cb.container);

	  if (send_traps_on_startup == TRUE) {
	    send_saHpiSensorTable_notification(sensor_context);
	  }

    }
    rc = AGENT_ERR_NOERROR;
  } else
    rc = AGENT_ERR_OPERATION;

  DEBUGMSGTL((AGENT,"\n\t--- populate_sensor. Exit\n"));
  return rc;
}


int  
saHpiSensorTable_modify_context(
				SaHpiSensorRecT *entry,
				SaHpiSensorThresholdsT *sensor_threshold,
				SaHpiResourceIdT resource_id,
				oid *rdr_entry, size_t rdr_entry_oid_len,
				saHpiSensorTable_context *ctx) {

  long hash;
  int i;
  SaHpiSensorDataFormatT data;
  SaHpiSensorThdDefnT thd;
  SaHpiSensorReadingT *reading;

  DEBUGMSGTL((AGENT,"Sensor threshold: %x\n", sensor_threshold));
  // Make sure they are valid.
  if (entry && ctx) {
    
    // We are subtracting SaHpiTextBufferT b/c the underlaying HPI
    // library is not zeroing out the memory for not used entries -
    // thus garbage in SaHpiTextBufferT exist,
    hash = calculate_hash_value(entry, sizeof(SaHpiSensorRecT));
    
    DEBUGMSGTL((AGENT," Hash value: %d, in ctx: %d\n", hash, ctx->hash));

    if (ctx->hash != 0) {
      // Only do the check if the hash value is something else than zero.
      // 'zero' value is only for newly created records, and in some
      // rare instances when the hash has rolled to zero - in which
      // case we will just consider the worst-case scenario and update
      // the record and not trust the hash value.
      if (hash == ctx->hash) {
	// The same data. No need to change.
	return AGENT_ENTRY_EXIST;
      }
    }

    ctx->hash = hash;
    data = entry->DataFormat;
    thd = entry->ThresholdDefn;
    DEBUGMSGTL((AGENT,"Creating columns for: %d\n", entry->Num));

    ctx->saHpiSensorRDR_len = rdr_entry_oid_len * sizeof(oid);
    memcpy(ctx->saHpiSensorRDR, rdr_entry, ctx->saHpiSensorRDR_len);


    ctx->saHpiSensorIndex = entry->Num;
    ctx->saHpiSensorType = entry->Type;
    ctx->saHpiSensorCategory = entry->Category;
    ctx->resource_id = resource_id;
    // IBM-KR: Adding +1
    ctx->saHpiSensorEventsCategoryControl = entry->EventCtrl+1;
    // IBM-KR: Revised in the future MIB - more columns possible
    ctx->saHpiSensorEventsState = entry->Events;       
    // TRUE=1 -> true(1), FALSE=0, false(2)
    
    ctx->saHpiSensorIgnore = (entry->Ignore == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

    ctx->saHpiSensorReadingFormats = data.ReadingFormats;
    ctx->saHpiSensorIsNumeric = (data.IsNumeric == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

    ctx->saHpiSensorSignFormat = data.SignFormat;
    ctx->saHpiSensorBaseUnits = data.BaseUnits;
    ctx->saHpiSensorModifierUnits = data.ModifierUnits;
    ctx->saHpiSensorModifierUse = data.ModifierUse;
    ctx->saHpiSensorFactorsStatic = (data.FactorsStatic == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

    // Sensor factors.
    memset(ctx->saHpiSensorFactors, 0x00, SAHPISENSORFACTORS_MAX);
    // Normalize data.
    data.Factors.M_Factor = htons(data.Factors.M_Factor);
    data.Factors.B_Factor = htons(data.Factors.B_Factor);
    data.Factors.AccuracyFactor = htons (data.Factors.AccuracyFactor);

    memcpy(ctx->saHpiSensorFactors, &data.Factors.M_Factor, sizeof(SaHpiInt16T));
    memcpy( ctx->saHpiSensorFactors + sizeof(SaHpiInt16T), &data.Factors.B_Factor, sizeof(SaHpiInt16T));

    memcpy(ctx->saHpiSensorFactors + (sizeof(SaHpiInt16T)*2),
	   &data.Factors.AccuracyFactor, sizeof(SaHpiUint16T));

    ctx->saHpiSensorFactors[6] = data.Factors.ToleranceFactor;
    ctx->saHpiSensorFactors[7] = data.Factors.ExpA;
    ctx->saHpiSensorFactors[8] = data.Factors.ExpR;
    ctx->saHpiSensorFactors[9] = data.Factors.ExpB;
    ctx->saHpiSensorFactors_len = SAHPISENSORFACTORS_MAX;

    ctx->saHpiSensorFactorsLinearization = data.Factors.Linearization;

    ctx->saHpiSensorPercentage = (data.Percentage == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

    ctx->saHpiSensorRangeFlags = data.Range.Flags;
    // Clean the memory.
    memset(ctx->saHpiSensorRangeReadingValuesPresent, 0x00, SAHPI_RANGE_VALUES_MAX);
    memset(ctx->saHpiSensorRangeReadingRaw, 0x00, SAHPI_RANGE_RAW_MAX);
    memset(ctx->saHpiSensorRangeReadingInterpreted, 0x00, SAHPI_RANGE_INTERPRETED_MAX);
    memset(ctx->saHpiSensorRangeReadingEventSensor, 0x00, SAHPI_RANGE_EVENT_SENSOR_MAX);

    // Set the structures.
    sensor_reading[SENSOR_READING_MIN].reading = &data.Range.Min;
    sensor_reading[SENSOR_READING_MAX].reading = &data.Range.Max;
    sensor_reading[SENSOR_READING_NORMAL_MIN].reading = &data.Range.NormalMin;
    sensor_reading[SENSOR_READING_NORMAL_MAX].reading = &data.Range.NormalMax;
    sensor_reading[SENSOR_READING_NOMINAL].reading = &data.Range.Nominal;

    // TEST. The dummy plugin doesn't have these values filled, so we made some up to test the sub-agent.
    /*
      data.Range.Flags =  data.Range.Flags | SAHPI_SRF_NOMINAL;    
      data.Range.Nominal.ValuesPresent = SAHPI_SRF_INTERPRETED;
      data.Range.Nominal.Interpreted.Value.SensorUint32 = 0x12345678;
      data.Range.Nominal.Interpreted.Type = SAHPI_SENSOR_INTERPRETED_TYPE_UINT32;

      data.Range.Flags = data.Range.Flags | SAHPI_SRF_NORMAL_MIN;
      data.Range.NormalMin.ValuesPresent = SAHPI_SRF_INTERPRETED;
      data.Range.NormalMin.Interpreted.Type = SAHPI_SENSOR_INTERPRETED_TYPE_BUFFER;
      strncpy(data.Range.NormalMin.Interpreted.Value.SensorBuffer, "aaaabbbbcccc", 12);

      data.Range.Flags = data.Range.Flags | SAHPI_SRF_NORMAL_MAX;
      data.Range.NormalMax.ValuesPresent = SAHPI_SRF_EVENT_STATE;
      data.Range.NormalMax.EventStatus.SensorStatus = SAHPI_SENSTAT_EVENTS_ENABLED;
      data.Range.NormalMax.EventStatus.EventStatus = SAHPI_ES_INSTALL_ERROR;
    */

    for (i = 0; i< SENSOR_READING_COUNT;i++) {
      //DEBUGMSGTL((AGENT,"%X & %X = %X\n", data.Range.Flags, sensor_reading[i].flag,
      //	  (data.Range.Flags & sensor_reading[i].flag)));
      if (data.Range.Flags & sensor_reading[i].flag) {
	reading = sensor_reading[i].reading;
	// Set the flag in the proper spot.
	ctx->saHpiSensorRangeReadingValuesPresent[sensor_reading[i].pos] = \
	  reading->ValuesPresent;

	// See which type of data it is
	if (reading->ValuesPresent & SAHPI_SRF_RAW) {
	  reading->Raw = htonl (reading->Raw);
	  memcpy(ctx->saHpiSensorRangeReadingRaw + 
		 (sensor_reading[i].pos*SIZEOF_UINT32),
		 &reading->Raw, SIZEOF_UINT32);
	  //DEBUGMSGTL((AGENT,"%d is SAHPI_SRF_RAW, value is %X -> [%X]\n",
	  //      i, reading->Raw, (ctx->saHpiSensorRangeReadingRaw +
	  //      (sensor_reading[i].pos*SIZEOF_UINT32))));
	}

	if (reading->ValuesPresent & SAHPI_SRF_INTERPRETED) {
	  switch (reading->Interpreted.Type) {
	  case SAHPI_SENSOR_INTERPRETED_TYPE_INT16:
	  case SAHPI_SENSOR_INTERPRETED_TYPE_UINT16:       	
	    reading->Interpreted.
	      Value.
	      SensorUint16 = htons(reading->Interpreted.
				   Value.
				   SensorUint16);	    
	    break;							 
	  case SAHPI_SENSOR_INTERPRETED_TYPE_INT32:
	  case SAHPI_SENSOR_INTERPRETED_TYPE_UINT32:
	    reading->Interpreted.
	      Value.
	      SensorUint32 = htonl(reading->Interpreted.
				   Value.
				   SensorUint32);
	    break;
	  case SAHPI_SENSOR_INTERPRETED_TYPE_FLOAT32:
	    break;
	  case SAHPI_SENSOR_INTERPRETED_TYPE_UINT8:
	  case SAHPI_SENSOR_INTERPRETED_TYPE_INT8:
	    break;
	  case SAHPI_SENSOR_INTERPRETED_TYPE_BUFFER:
	    break;
	  }
	  memcpy(ctx->saHpiSensorRangeReadingInterpreted+
		 (sensor_reading[i].pos*SAHPI_SENSOR_BUFFER_LENGTH),
		 &reading->Interpreted.Value, 
		 SAHPI_SENSOR_BUFFER_LENGTH);       
	}
	if (reading->ValuesPresent & SAHPI_SRF_EVENT_STATE) {	  
	  ctx->saHpiSensorRangeReadingEventSensor[sensor_reading[i].pos*3] = 
	    reading->EventStatus.SensorStatus;

	  reading->EventStatus.EventStatus = 
	    htons(reading->EventStatus.EventStatus);

	  memcpy(ctx->saHpiSensorRangeReadingEventSensor+
		 (sensor_reading[i].pos*3)+1,
		 &reading->EventStatus.EventStatus, 
		 SIZEOF_UINT16);
	}
      }
    }
    
    ctx->saHpiSensorRangeReadingValuesPresent_len = SAHPI_RANGE_VALUES_MAX;
    ctx->saHpiSensorRangeReadingRaw_len = SAHPI_RANGE_RAW_MAX;
    ctx->saHpiSensorRangeReadingInterpreted_len =  SAHPI_RANGE_INTERPRETED_MAX;
    ctx->saHpiSensorRangeReadingEventSensor_len = SAHPI_RANGE_EVENT_SENSOR_MAX;
    
    ctx->saHpiSensorThresholdDefnIsThreshold = (thd.IsThreshold == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

    ctx->saHpiSensorThresholdDefnTholdCapabilities = 
      thd.TholdCapabilities;

    ctx->saHpiSensorThresholdDefnReadThold = thd.ReadThold;
    ctx->saHpiSensorThresholdDefnWriteThold = thd.WriteThold;
    ctx->saHpiSensorThresholdDefnFixedThold = thd.FixedThold;
    
   
    fill_sensor_threshold_info(ctx, sensor_threshold);

    
    ctx->saHpiSensorOEM = entry->Oem;
   
    return AGENT_NEW_ENTRY;
  }
  
  return AGENT_ERR_NULL_DATA;
}

void fill_sensor_threshold_info(saHpiSensorTable_context *ctx, 
				SaHpiSensorThresholdsT *sensor_threshold) {

  int i;
  DEBUGMSGTL((AGENT,"fill_sensor_threshold_info: Entry.\n"));

  if (sensor_threshold) {
    memset(ctx->saHpiSensorThresholdInterpreted, 0x00, THRESHOLD_RAW_MAX);
    memset(ctx->saHpiSensorThresholdRaw, 0x00, THRESHOLD_INTERPRETED_MAX);
    ctx->saHpiSensorThresholdInterpreted_len = 0;
    ctx->saHpiSensorThresholdRaw_len = 0;

    sensor_thd[SENSOR_THD_LOW_MINOR].reading = 
      &sensor_threshold->LowMinor;
    sensor_thd[SENSOR_THD_LOW_MAJOR].reading =
      &sensor_threshold->LowMajor;
    sensor_thd[SENSOR_THD_LOW_CRIT].reading =
      &sensor_threshold->LowCritical;
    sensor_thd[SENSOR_THD_UP_MINOR].reading =
      &sensor_threshold->UpMinor;
    sensor_thd[SENSOR_THD_UP_MAJOR].reading =
      &sensor_threshold->UpMajor;
    sensor_thd[SENSOR_THD_UP_CRIT].reading =
      &sensor_threshold->UpCritical;
    sensor_thd[SENSOR_THD_UP_HYSTERESIS].reading =
      &sensor_threshold->PosThdHysteresis;
    sensor_thd[SENSOR_THD_LOW_HYSTERESIS].reading =
      &sensor_threshold->NegThdHysteresis;
    /* TEST
       ctx->saHpiSensorThresholdDefnTholdCapabilities = SAHPI_STC_INTERPRETED;
       sensor_threshold->LowMinor.Interpreted.Type= 0xFF;
       sensor_threshold->UpCritical.Interpreted.Type = 0xAA;
       strncpy(sensor_threshold->LowMinor.Interpreted.Value.SensorBuffer,
       "aaaabbbbccccddddeeeeffffgggghhhhxzxzxzxzxz", 32);
       strncpy(sensor_threshold->UpCritical.Interpreted.Value.SensorBuffer,
       "aaaabbbbccccddddeeeeffffgggghhhhxzxzxzxzxzxzxz", 32);
    */
    if  (ctx->saHpiSensorThresholdDefnTholdCapabilities & SAHPI_STC_RAW) {       
      DEBUGMSGTL((AGENT,"Values are SAHPI_STC_RAW\n"));
      for (i = 0; i< SENSOR_THD_COUNT; i++) {
	// Normalize the data and put it in saHpiSensorThresholdRaw
	sensor_thd[i].reading->Raw = htonl(sensor_thd[i].reading->Raw);
	memcpy(ctx->saHpiSensorThresholdRaw + 
	       (sensor_thd[i].pos * SIZEOF_UINT32),
	       &sensor_thd[i].reading->Raw,
	       SIZEOF_UINT32);
	//DEBUGMSGTL((AGENT,"%d: Raw: %X at %X (base is %X)\n",
	//	    i, sensor_thd[i].reading->Raw,
	//    ctx->saHpiSensorThresholdRaw + 
	//    (sensor_thd[i].pos * SIZEOF_UINT32),
	//     ctx->saHpiSensorThresholdRaw));
      }
      // Set the lenght
      ctx->saHpiSensorThresholdRaw_len = THRESHOLD_RAW_MAX;
    }
    // Can't do 'else' b/c its a bit flag.
    if (ctx->saHpiSensorThresholdDefnTholdCapabilities & SAHPI_STC_INTERPRETED) {      
      DEBUGMSGTL((AGENT,"Values are SAHPI_STC_RAW\n"));
      for (i = 0; i<SENSOR_THD_COUNT; i++) {
	// Convert from our platform to network order
	switch (sensor_thd[i].reading->Interpreted.Type) {
	case  SAHPI_SENSOR_INTERPRETED_TYPE_UINT16:
	case  SAHPI_SENSOR_INTERPRETED_TYPE_INT16:
	  sensor_thd[i].reading->Interpreted.Value.SensorUint16 =
	    htons( sensor_thd[i].reading->Interpreted.Value.SensorUint16);
	  break;
	case SAHPI_SENSOR_INTERPRETED_TYPE_UINT32:
	case SAHPI_SENSOR_INTERPRETED_TYPE_INT32:
	   sensor_thd[i].reading->Interpreted.Value.SensorUint32 =
	    htonl(sensor_thd[i].reading->Interpreted.Value.SensorUint32);
	   break;
	default:
	  break;
	}
	// Copy the type of data (uint8, 16, 32, float, etc)
	ctx->saHpiSensorThresholdInterpreted[sensor_thd[i].pos * (SAHPI_SENSOR_BUFFER_LENGTH +1)] = 
	  sensor_thd[i].reading->Interpreted.Type;
	// Copy the data.
	memcpy (ctx->saHpiSensorThresholdInterpreted + 1 +
		(sensor_thd[i].pos * (1+SAHPI_SENSOR_BUFFER_LENGTH)),
		sensor_thd[i].reading->Interpreted.Value.SensorBuffer,
		SAHPI_SENSOR_BUFFER_LENGTH);
	//DEBUGMSGTL((AGENT,"%d: Type: %X at %X (base is %X)\n",
	//    i, sensor_thd[i].reading->Interpreted.Type,
	//   ctx->saHpiSensorThresholdInterpreted + 
	//   (sensor_thd[i].pos * 32) + 1,
	//    ctx->saHpiSensorThresholdInterpreted));
      }
      ctx->saHpiSensorThresholdInterpreted_len = THRESHOLD_INTERPRETED_MAX;
    }  
  }
  DEBUGMSGTL((AGENT,"fill_sensor_threshold_info: Exit.\n"));
}

int set_sensor(saHpiSensorTable_context *ctx) {

  SaHpiSensorThresholdsT thd;
  SaHpiSessionIdT session_id;
  SaErrorT rc; 
  int i;
  

  DEBUGMSGTL((AGENT,"set_sensor: Entry.\n"));
  if (ctx) {
    // Set up the table
    sensor_thd[SENSOR_THD_LOW_MINOR].reading = 
      &thd.LowMinor;
    sensor_thd[SENSOR_THD_LOW_MAJOR].reading =
      &thd.LowMajor;
    sensor_thd[SENSOR_THD_LOW_CRIT].reading =
      &thd.LowCritical;
    sensor_thd[SENSOR_THD_UP_MINOR].reading =
      &thd.UpMinor;
    sensor_thd[SENSOR_THD_UP_MAJOR].reading =
      &thd.UpMajor;
    sensor_thd[SENSOR_THD_UP_CRIT].reading =
      &thd.UpCritical;
    sensor_thd[SENSOR_THD_UP_HYSTERESIS].reading =
      &thd.PosThdHysteresis;
    sensor_thd[SENSOR_THD_LOW_HYSTERESIS].reading =
      &thd.NegThdHysteresis;

    memset(&thd, 0x00, sizeof(SaHpiSensorThresholdsT));
    // Check in saHpiSensorThresholdDefnWriteThold to see which
    // values can be put in 'thd' and only put those in
    for (i = 0; i < SENSOR_THD_COUNT;i++) {
      if (ctx->saHpiSensorThresholdDefnWriteThold & sensor_thd[i].bit) {
	DEBUGMSGTL((AGENT,"%d: %X is writeable\n", i, sensor_thd[i].bit));
	if (ctx->saHpiSensorThresholdDefnTholdCapabilities & SAHPI_STC_RAW) {
	  // Put the data in the SaHpiSensorThresholdsT.<name>.Raw	  
	  memcpy(&sensor_thd[i].reading->Raw,
		 ctx->saHpiSensorThresholdRaw + 
		 (sensor_thd[i].pos * SIZEOF_UINT32),
		 SIZEOF_UINT32);
	  // Convert back to our platform type.
	  sensor_thd[i].reading->Raw = ntohl(sensor_thd[i].reading->Raw);
	  DEBUGMSGTL((AGENT,"SAHPI_STC_RAW: %X\n", sensor_thd[i].reading->Raw));
	}
	if (ctx->saHpiSensorThresholdDefnTholdCapabilities & SAHPI_STC_INTERPRETED) {
	  // Put the data in the SaHpiSensor.<name>.Intepreted		
	  memcpy (&sensor_thd[i].reading->Interpreted.Value.SensorBuffer,
		  ctx->saHpiSensorThresholdInterpreted + 1 +
		  (sensor_thd[i].pos * (1+SAHPI_SENSOR_BUFFER_LENGTH)),
		  SAHPI_SENSOR_BUFFER_LENGTH);
	  // In the type.
	  sensor_thd[i].reading->Interpreted.Type = 
	    ctx->saHpiSensorThresholdInterpreted[sensor_thd[i].pos * (SAHPI_SENSOR_BUFFER_LENGTH +1)];
	  // Convert from Network Order to our platform,.
	  switch (sensor_thd[i].reading->Interpreted.Type) {
	  case  SAHPI_SENSOR_INTERPRETED_TYPE_UINT16:
	  case  SAHPI_SENSOR_INTERPRETED_TYPE_INT16:
	    sensor_thd[i].reading->Interpreted.Value.SensorUint16 =
	      ntohs( sensor_thd[i].reading->Interpreted.Value.SensorUint16);
	    break;
	  case SAHPI_SENSOR_INTERPRETED_TYPE_UINT32:
	  case SAHPI_SENSOR_INTERPRETED_TYPE_INT32:
	    sensor_thd[i].reading->Interpreted.Value.SensorUint32 =
	      ntohl(sensor_thd[i].reading->Interpreted.Value.SensorUint32);
	    break;
	  default:
	    break;
	  }
	  DEBUGMSGTL((AGENT,"SAHPI_SRC_INTERPRETED.\n"));
	}
      }
    }    
      // Get the seesion_id
    rc = getSaHpiSession(&session_id);
    if (rc != AGENT_ERR_NOERROR) 
      return rc;
     
    DEBUGMSGTL((AGENT,"Calling saHpiSensorThresholdsSet with SensorNum: %d\n", ctx->saHpiSensorIndex ));
    rc = saHpiSensorThresholdsSet(session_id, 
				ctx->resource_id,
				ctx->saHpiSensorIndex,
				&thd);

    DEBUGMSGTL((AGENT,"rc is %d, SA_OK is %d\n", rc, SA_OK));
    if (rc != SA_OK) {
	return AGENT_ERR_OPERATION;
    }

    // Re-read the data. Should be exactly the same.      
    DEBUGMSGTL((AGENT,"Calling SensorThresholdGet\n"));
    memset(&thd, 0x00, sizeof(SaHpiSensorThresholdsT));
    rc = saHpiSensorThresholdsGet(session_id,
				  ctx->resource_id,
				  ctx->saHpiSensorIndex,
				  &thd);

    DEBUGMSGTL((AGENT,"rc is %d, SA_OK is %d\n", rc, SA_OK));
    if (rc != SA_OK) {
	return AGENT_ERR_OPERATION;
    }
    // Put the latest data.
    fill_sensor_threshold_info(ctx, &thd);

    return AGENT_ERR_NOERROR;
  }
  DEBUGMSGTL((AGENT,"set_sensor: Exit.\n"));
  return AGENT_ERR_NULL_DATA;
}



int
send_saHpiSensorTable_notification(saHpiSensorTable_context *ctx) {

  netsnmp_variable_list *notification_vars = NULL;
  oid snmptrap[] = { snmptrap_oid };

  DEBUGMSGTL((AGENT,"--- send_saHpiSensorTable_notification: Entry.\n"));  

  snmp_varlist_add_variable(&notification_vars,
			    snmptrap, OID_LENGTH(snmptrap),
			    ASN_OBJECT_ID,
			    (u_char *)saHpiSensorNotification_oid,
			    OID_LENGTH(saHpiSensorNotification_oid)* sizeof(oid));

  /*
  make_SaHpiSensorTable_trap_msg(notification_vars,
			      &ctx->index,
			      COLUMN_SAHPIRDRRESOURCEID,
			      ASN_UNSIGNED,
			      (char *)&ctx->saHpiResourceID,
			      sizeof(ctx->saHpiResourceID));

  make_SaHpiRdrTable_trap_msg(notification_vars,
			      &ctx->index,
			      COLUMN_SAHPIRDRRECORDID,
			      ASN_UNSIGNED,
			      (char *)&ctx->saHpiRdrRecordId,
			      sizeof(ctx->saHpiRdrRecordId));
  
  make_SaHpiRdrTable_trap_msg(notification_vars,
		&ctx->index,
		COLUMN_SAHPIRDRTYPE,
		ASN_INTEGER,
		(char *)&ctx->saHpiRdrType,
		sizeof(ctx->saHpiRdrType));

 make_SaHpiRdrTable_trap_msg(notification_vars,
	       &ctx->index,
	       COLUMN_SAHPIRDRENTITYPATH,
	       ASN_OCTET_STR,
	       ctx->saHpiRdrEntityPath,
	       ctx->saHpiRdrEntityPath_len);

 make_SaHpiRdrTable_trap_msg(notification_vars,
		&ctx->index,
		COLUMN_SAHPIRDR,
		ASN_OBJECT_ID,
		(char *)ctx->saHpiRdr,
		sizeof(oid)*ctx->saHpiRdr_len);

  make_SaHpiRdrTable_trap_msg(notification_vars,
		&ctx->index,
		COLUMN_SAHPIRDRRTP,
		ASN_OBJECT_ID,
		(char *)ctx->saHpiRdrRTP,
		sizeof(oid)*ctx->saHpiRdrRTP_len);
  */

 snmp_varlist_add_variable(&notification_vars,
			   saHpiSensorCount_oid, OID_LENGTH(saHpiSensorCount_oid),
			   ASN_COUNTER,
			   (char *)&sensor_count,
			   sizeof(sensor_count));

  send_v2trap(notification_vars);

  snmp_free_varbind(notification_vars);
  DEBUGMSGTL((AGENT,"--- send_saHpiSensorTable_notification: Exit.\n"));
  return 0;
}
void
make_SaHpiSensorTable_trap_msg(netsnmp_variable_list *list, 
	      netsnmp_index *index,
	      int col, 
	      u_char type,
	      const u_char *value, 
	      const size_t value_len) {

  oid entries[MAX_OID_LEN];
  int len;
  oid column[2];


  column[0] = 1; // wonder where this comes from? Look at the HPI MIB
  column[1] = col;

  build_full_oid(saHpiSensorTable_oid, saHpiSensorTable_oid_len,
		 column, 2,
		 index,
		 entries, MAX_OID_LEN, &len);
  DEBUGMSGTL((AGENT,"\n"));
  DEBUGMSGOID((AGENT,entries, len));
  DEBUGMSGTL((AGENT,"\n"));

 snmp_varlist_add_variable(&list,
			   entries, len,
			   type,
			   value,
			   value_len);
			
  
}

/************************************************************
 * keep binary tree to find context by name
 */
//static int      saHpiSensorTable_cmp(const void *lhs, const void *rhs);

/************************************************************
 * compare two context pointers here. Return -1 if lhs < rhs,
 * 0 if lhs == rhs, and 1 if lhs > rhs.
 */
/*
static int
saHpiSensorTable_cmp(const void *lhs, const void *rhs)
{
    saHpiSensorTable_context *context_l =
        (saHpiSensorTable_context *) lhs;
    saHpiSensorTable_context *context_r =
        (saHpiSensorTable_context *) rhs;


    if (context_l->saHpiSensorIndex < context_r->saHpiSensorIndex) 
      return -1;

    return (context_l->saHpiSensorIndex == context_r->saHpiSensorIndex) ? 0 : 1;

}

*/
/************************************************************
 * the *_row_copy routine
 */
static int
saHpiSensorTable_row_copy(saHpiSensorTable_context * dst,
                           saHpiSensorTable_context * src)
{
    if (!dst || !src)
        return 1;

    /*
     * copy index, if provided
     */
    if (dst->index.oids)
        free(dst->index.oids);
    if (snmp_clone_mem((void *) &dst->index.oids, src->index.oids,
                       src->index.len * sizeof(oid))) {
        dst->index.oids = NULL;
        return 1;
    }
    dst->index.len = src->index.len;


    /*
     * copy components into the context structure
     */
    dst->saHpiSensorIndex = src->saHpiSensorIndex;

    dst->saHpiSensorType = src->saHpiSensorType;

    dst->saHpiSensorCategory = src->saHpiSensorCategory;

    dst->saHpiSensorEventsCategoryControl =
        src->saHpiSensorEventsCategoryControl;

    dst->saHpiSensorEventsState = src->saHpiSensorEventsState;

    dst->saHpiSensorIgnore =src->saHpiSensorIgnore;

    dst->saHpiSensorReadingFormats = src->saHpiSensorReadingFormats;

    dst->saHpiSensorIsNumeric = src->saHpiSensorIsNumeric;

    dst->saHpiSensorSignFormat = src->saHpiSensorSignFormat;

    dst->saHpiSensorBaseUnits = src->saHpiSensorBaseUnits;

    dst->saHpiSensorModifierUnits = src->saHpiSensorModifierUnits;

    dst->saHpiSensorModifierUse = src->saHpiSensorModifierUse;

    dst->saHpiSensorFactorsStatic =src->saHpiSensorFactorsStatic;

    memcpy(dst->saHpiSensorFactors, src->saHpiSensorFactors,
           src->saHpiSensorFactors_len);
    dst->saHpiSensorFactors_len = src->saHpiSensorFactors_len;

    dst->saHpiSensorFactorsLinearization =
        src->saHpiSensorFactorsLinearization;

    dst->saHpiSensorPercentage = src->saHpiSensorPercentage;

    dst->saHpiSensorRangeFlags = src->saHpiSensorRangeFlags;

    memcpy(dst->saHpiSensorRangeReadingValuesPresent,
           src->saHpiSensorRangeReadingValuesPresent,
           src->saHpiSensorRangeReadingValuesPresent_len);
    dst->saHpiSensorRangeReadingValuesPresent_len =
        src->saHpiSensorRangeReadingValuesPresent_len;

    memcpy(dst->saHpiSensorRangeReadingRaw,
           src->saHpiSensorRangeReadingRaw,
           src->saHpiSensorRangeReadingRaw_len);
    dst->saHpiSensorRangeReadingRaw_len =
        src->saHpiSensorRangeReadingRaw_len;

    memcpy(dst->saHpiSensorRangeReadingInterpreted,
           src->saHpiSensorRangeReadingInterpreted,
           src->saHpiSensorRangeReadingInterpreted_len);
    dst->saHpiSensorRangeReadingInterpreted_len =
        src->saHpiSensorRangeReadingInterpreted_len;

    memcpy(dst->saHpiSensorRangeReadingEventSensor,
           src->saHpiSensorRangeReadingEventSensor,
           src->saHpiSensorRangeReadingEventSensor_len);
    dst->saHpiSensorRangeReadingEventSensor_len =
        src->saHpiSensorRangeReadingEventSensor_len;

    dst->saHpiSensorThresholdDefnIsThreshold = 
      src->saHpiSensorThresholdDefnIsThreshold;

    dst->saHpiSensorThresholdDefnTholdCapabilities =
      src->saHpiSensorThresholdDefnTholdCapabilities;


    dst->saHpiSensorThresholdDefnReadThold =
        src->saHpiSensorThresholdDefnReadThold;

    dst->saHpiSensorThresholdDefnWriteThold =
        src->saHpiSensorThresholdDefnWriteThold;

    dst->saHpiSensorThresholdDefnFixedThold =
        src->saHpiSensorThresholdDefnFixedThold;

    memcpy(dst->saHpiSensorThresholdRaw, src->saHpiSensorThresholdRaw,
           src->saHpiSensorThresholdRaw_len);
    dst->saHpiSensorThresholdRaw_len = src->saHpiSensorThresholdRaw_len;

    memcpy(dst->saHpiSensorThresholdInterpreted,
           src->saHpiSensorThresholdInterpreted,
           src->saHpiSensorThresholdInterpreted_len);
    dst->saHpiSensorThresholdInterpreted_len =
        src->saHpiSensorThresholdInterpreted_len;

    dst->saHpiSensorOEM = src->saHpiSensorOEM;

    dst->saHpiSensorRDR_len = src->saHpiSensorRDR_len;

    memcpy(src->saHpiSensorRDR, dst->saHpiSensorRDR,
	   src->saHpiSensorRDR_len );


    dst->resource_id = src->resource_id;
    dst->hash = src->hash;

    return 0;
}



/*
 * the *_extract_index routine
 */
int
saHpiSensorTable_extract_index(saHpiSensorTable_context * ctx,
                                netsnmp_index * hdr)
{
    /*
     * temporary local storage for extracting oid index
     */
    netsnmp_variable_list var_saHpiSensorIndex;
    int             err;

    /*
     * copy index, if provided
     */
    if (hdr) {
        netsnmp_assert(ctx->index.oids == NULL);
        if (snmp_clone_mem((void *) &ctx->index.oids, hdr->oids,
                           hdr->len * sizeof(oid))) {
            return -1;
        }
        ctx->index.len = hdr->len;
    }

    /**
     * Create variable to hold each component of the index
     */
    memset(&var_saHpiSensorIndex, 0x00, sizeof(var_saHpiSensorIndex));
    var_saHpiSensorIndex.type = ASN_UNSIGNED;
    var_saHpiSensorIndex.next_variable = NULL;

    /*
     * parse the oid into the individual components
     */
    err = parse_oid_indexes(hdr->oids, hdr->len, &var_saHpiSensorIndex);
    if (err == SNMP_ERR_NOERROR) {       
        ctx->saHpiSensorIndex = *var_saHpiSensorIndex.val.integer;    
    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers(&var_saHpiSensorIndex);

    return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int
saHpiSensorTable_can_delete(saHpiSensorTable_context * undo_ctx,
                             saHpiSensorTable_context * row_ctx,
                             netsnmp_request_group * rg)
{
  DEBUGMSGTL((AGENT,"can_delete\n"));
    return 1;
}


/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated saHpiSensorTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
saHpiSensorTable_context *
saHpiSensorTable_create_row(netsnmp_index * hdr)
{
    saHpiSensorTable_context *ctx =
        SNMP_MALLOC_TYPEDEF(saHpiSensorTable_context);
    if (!ctx)
        return NULL;

    if (saHpiSensorTable_extract_index(ctx, hdr)) {
        free(ctx->index.oids);
        free(ctx);
        return NULL;
    }

  
    ctx->hash = 0;
    return ctx;
}


/************************************************************
 * the *_duplicate row routine
 */
saHpiSensorTable_context *
saHpiSensorTable_duplicate_row(saHpiSensorTable_context * row_ctx)
{
    saHpiSensorTable_context *dup;
    DEBUGMSGTL((AGENT,"duplicate_row\n"));
    if (!row_ctx)
        return NULL;

    dup = SNMP_MALLOC_TYPEDEF(saHpiSensorTable_context);
    if (!dup)
        return NULL;

    if (saHpiSensorTable_row_copy(dup, row_ctx)) {
        free(dup);
        dup = NULL;
    }

    return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index  *
saHpiSensorTable_delete_row(saHpiSensorTable_context * ctx)
{
  DEBUGMSGTL((AGENT,"delete_row"));
    if (ctx->index.oids)
        free(ctx->index.oids);


    free(ctx);

    return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void
saHpiSensorTable_set_reserve1(netsnmp_request_group * rg)
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;
    int             rc = SNMP_ERR_NOERROR;

    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_reserve1. Entry\n"));
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
            rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
						THRESHOLD_RAW_MAX);
            break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
            rc = netsnmp_check_vb_type_and_size(var, ASN_OCTET_STR,
						THRESHOLD_INTERPRETED_MAX);
            break;

        default:/** We shouldn't get here */
            rc = SNMP_ERR_GENERR;
            snmp_log(LOG_ERR, "unknown column in "
                     "saHpiSensorTable_set_reserve1\n");
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri,
                                           rc);
        rg->status = SNMP_MAX(rg->status, current->ri->status);
    }

    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_reserve1: Exit (rc:%d)\n", rc));
}

void
saHpiSensorTable_set_reserve2(netsnmp_request_group * rg)
{
  saHpiSensorTable_context *row_ctx =
    (saHpiSensorTable_context *) rg->existing_row;
  saHpiSensorTable_context *undo_ctx =
    (saHpiSensorTable_context *) rg->undo_info;
    netsnmp_request_group_item *current;
    netsnmp_variable_list *var;
    int             rc = SNMP_ERR_NOERROR;
    int i;
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_reserve2: Entry\n"));
    rg->rg_void = rg->list->ri;

    
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;
        rc = SNMP_ERR_NOERROR;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
	  // If not defined as writeable, check to make sure its not modified
	  for (i=0; i< SENSOR_THD_COUNT;i++) {
	    if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & sensor_thd[i].bit)) { 
	      // The data for which the write bit is not SET, is set to \0
	      DEBUGMSGTL((AGENT,"%d: Setting %X to ZERO\n", i, var->val.string));
	      memset(var->val.string + (sensor_thd[i].pos * SIZEOF_UINT32),
		     0x00, SIZEOF_UINT32);
	    }
	  }
	  break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
	  /*
	   if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_LOW_MINOR)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_LOW_MINOR);
	  }
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_LOW_MAJOR)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_LOW_MAJOR);
	  }
	  
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_LOW_CRIT)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_LOW_CRITICAL);
	  }

	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_UP_MINOR)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_UP_MINOR);
	  }
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_UP_MAJOR)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_UP_MAJOR);
	  }
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_UP_CRIT)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_UP_CRITICAL);
	  }
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_UP_HYSTERESIS)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx, POS_POS_THD_HYSTERESIS);
	  }
	  if (!(row_ctx->saHpiSensorThresholdDefnWriteThold & SAHPI_STM_LOW_HYSTERESIS)) {
	    CHECK_THRESHOLD_INTERPRETED(row_ctx, undo_ctx,  POS_NEG_THD_HYSTERESIS);
	  }
	  */	  
	      break;

        default:/** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
	    break;
        }

        if (rc)
            netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri,
                                           rc);
    }
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_reserve2: Exit (rc: %d)\n", rc));
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void
saHpiSensorTable_set_action(netsnmp_request_group * rg)
{
    netsnmp_variable_list *var;
        saHpiSensorTable_context *row_ctx =
        (saHpiSensorTable_context *) rg->existing_row;

    netsnmp_request_group_item *current;
    
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_action: Entry\n"));
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
            memcpy(row_ctx->saHpiSensorThresholdRaw, var->val.string,
                   var->val_len);
            row_ctx->saHpiSensorThresholdRaw_len = var->val_len;	  
            break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
            memcpy(row_ctx->saHpiSensorThresholdInterpreted,
                   var->val.string, var->val_len);
            row_ctx->saHpiSensorThresholdInterpreted_len = var->val_len;	    
            break;

        default:/** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
	    break;
        }
	DEBUGMSGTL((AGENT,"saHpiSensorTable_set_action: Loop\n"));
	if (set_sensor(row_ctx) != AGENT_ERR_NOERROR) {
	  DEBUGMSGTL((AGENT,"saHpiSensorTable_set_action: Error: SNMP_ERR_GENERR"));
	  netsnmp_set_mode_request_error(MODE_SET_BEGIN, current->ri,
					 SNMP_ERR_GENERR);
	}
    }
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_action: Exit \n"));
  
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void
saHpiSensorTable_set_commit(netsnmp_request_group * rg)
{
    netsnmp_variable_list *var;
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
            break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
            break;

        default:/** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
	    break;
        }
    }

    /*
     * done with all the columns. Could check row related
     * requirements here.
     */
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_commit: Entry & Exit\n"));
}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void
saHpiSensorTable_set_free(netsnmp_request_group * rg)
{
    netsnmp_variable_list *var;
    /*    saHpiSensorTable_context *row_ctx =
        (saHpiSensorTable_context *) rg->existing_row;
    saHpiSensorTable_context *undo_ctx =
    (saHpiSensorTable_context *) rg->undo_info;*/
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
            break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
            break;


            
        }
    }
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_free: Entry & Exit\n"));
}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void
saHpiSensorTable_set_undo(netsnmp_request_group * rg)
{
    netsnmp_variable_list *var;
    /*    saHpiSensorTable_context *row_ctx =
        (saHpiSensorTable_context *) rg->existing_row;
    saHpiSensorTable_context *undo_ctx =
    (saHpiSensorTable_context *) rg->undo_info;*/
    netsnmp_request_group_item *current;

    /*
     * loop through columns
     */
    for (current = rg->list; current; current = current->next) {

        var = current->ri->requestvb;

        switch (current->tri->colnum) {

        case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
            break;

        case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
            break;

        default:/** We shouldn't get here */
            netsnmp_assert(0); /** why wasn't this caught in reserve1? */
	    break;
        }
    }

  
    DEBUGMSGTL((AGENT,"saHpiSensorTable_set_undo: Entry & Exit\n"));
}




/************************************************************
 *
 * Initialize the saHpiSensorTable table by defining its contents and how it's structured
 */
void
initialize_table_saHpiSensorTable(void)
{
    netsnmp_table_registration_info *table_info;

    if (my_handler) {
        snmp_log(LOG_ERR,
                 "initialize_table_saHpiSensorTable_handler called again\n");
        return;
    }

    memset(&cb, 0x00, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("saHpiSensorTable",
                                                     netsnmp_table_array_helper_handler,
                                                     saHpiSensorTable_oid,
                                                     saHpiSensorTable_oid_len,
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info) {
        snmp_log(LOG_ERR, "malloc failed in "
                 "initialize_table_saHpiSensorTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
        /** index: saHpiSensorIndex */
    netsnmp_table_helper_add_index(table_info, ASN_UNSIGNED);

    table_info->min_column = saHpiSensorTable_COL_MIN;
    table_info->max_column = saHpiSensorTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = saHpiSensorTable_get_value;
    cb.container = netsnmp_container_find("saHpiSensorTable_primary:"
                                          "saHpiSensorTable:"
                                          "table_container");
    /*
#ifdef saHpiSensorTable_IDX2
    netsnmp_container_add_index(cb.container,
                                netsnmp_container_find
                                ("saHpiSensorTable_secondary:"
                                 "saHpiSensorTable:" "table_container"));
    cb.container->next->compare = saHpiSensorTable_cmp;
#endif
    */

    cb.can_set = 1;

    cb.create_row = (UserRowMethod *) saHpiSensorTable_create_row;

    cb.duplicate_row = (UserRowMethod *) saHpiSensorTable_duplicate_row;
    cb.delete_row = (UserRowMethod *) saHpiSensorTable_delete_row;
    cb.row_copy =
        (Netsnmp_User_Row_Operation *) saHpiSensorTable_row_copy;

    cb.can_delete =
        (Netsnmp_User_Row_Action *) saHpiSensorTable_can_delete;

    cb.set_reserve1 = saHpiSensorTable_set_reserve1;
    cb.set_reserve2 = saHpiSensorTable_set_reserve2;
    cb.set_action = saHpiSensorTable_set_action;
    cb.set_commit = saHpiSensorTable_set_commit;
    cb.set_free = saHpiSensorTable_set_free;
    cb.set_undo = saHpiSensorTable_set_undo;

    DEBUGMSGTL(("initialize_table_saHpiSensorTable",
                "Registering table saHpiSensorTable "
                "as a table array\n"));

    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);


    netsnmp_register_read_only_counter32_instance("sensor_count",
						  saHpiSensorCount_oid,
						  OID_LENGTH(saHpiSensorCount_oid),
						  &sensor_count,
						  NULL);
}

/************************************************************
 * saHpiSensorTable_get_value
 */
int
saHpiSensorTable_get_value(netsnmp_request_info *request,
                            netsnmp_index * item,
                            netsnmp_table_request_info *table_info)
{
    netsnmp_variable_list *var = request->requestvb;
    saHpiSensorTable_context *context =
        (saHpiSensorTable_context *) item;

    switch (table_info->colnum) {

    case COLUMN_SAHPISENSORINDEX:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->saHpiSensorIndex,
                                 sizeof(context->saHpiSensorIndex));
        break;

    case COLUMN_SAHPISENSORTYPE:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorType,
                                 sizeof(context->saHpiSensorType));
        break;

    case COLUMN_SAHPISENSORCATEGORY:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorCategory,
                                 sizeof(context->saHpiSensorCategory));
        break;

    case COLUMN_SAHPISENSOREVENTSCATEGORYCONTROL:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorEventsCategoryControl,
                                 sizeof(context->
                                        saHpiSensorEventsCategoryControl));
        break;

    case COLUMN_SAHPISENSOREVENTSSTATE:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->
                                 saHpiSensorEventsState,
                                 sizeof(context->saHpiSensorEventsState));
        break;

    case COLUMN_SAHPISENSORIGNORE:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *)&context->saHpiSensorIgnore,
                                 sizeof(context->saHpiSensorIgnore));
        break;

    case COLUMN_SAHPISENSORREADINGFORMATS:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->
                                 saHpiSensorReadingFormats,
                                 sizeof(context->
                                        saHpiSensorReadingFormats));
        break;

    case COLUMN_SAHPISENSORISNUMERIC:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorIsNumeric,
                                 sizeof(context->saHpiSensorIsNumeric));
        break;

    case COLUMN_SAHPISENSORSIGNFORMAT:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorSignFormat,
                                 sizeof(context->saHpiSensorSignFormat));
        break;

    case COLUMN_SAHPISENSORBASEUNITS:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorBaseUnits,
                                 sizeof(context->saHpiSensorBaseUnits));
        break;

    case COLUMN_SAHPISENSORMODIFIERUNITS:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorModifierUnits,
                                 sizeof(context->
                                        saHpiSensorModifierUnits));
        break;

    case COLUMN_SAHPISENSORMODIFIERUSE:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorModifierUse,
                                 sizeof(context->saHpiSensorModifierUse));
        break;

    case COLUMN_SAHPISENSORFACTORSSTATIC:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorFactorsStatic,
                                 sizeof(context->saHpiSensorFactorsStatic));
        break;

    case COLUMN_SAHPISENSORFACTORS:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->saHpiSensorFactors,
                                 context->saHpiSensorFactors_len);
        break;

    case COLUMN_SAHPISENSORFACTORSLINEARIZATION:
            /** INTEGER = ASN_INTEGER */
        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorFactorsLinearization,
                                 sizeof(context->
                                        saHpiSensorFactorsLinearization));
        break;

    case COLUMN_SAHPISENSORPERCENTAGE:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->saHpiSensorPercentage,
                                 sizeof(context->saHpiSensorPercentage));
        break;

    case COLUMN_SAHPISENSORRANGEFLAGS:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->saHpiSensorRangeFlags,
                                 sizeof(context->saHpiSensorRangeFlags));
        break;

    case COLUMN_SAHPISENSORRANGEREADINGVALUESPRESENT:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorRangeReadingValuesPresent,
                                 context->
                                 saHpiSensorRangeReadingValuesPresent_len);
        break;

    case COLUMN_SAHPISENSORRANGEREADINGRAW:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorRangeReadingRaw,
                                 context->saHpiSensorRangeReadingRaw_len);
        break;

    case COLUMN_SAHPISENSORRANGEREADINGINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorRangeReadingInterpreted,
                                 context->
                                 saHpiSensorRangeReadingInterpreted_len);
        break;

    case COLUMN_SAHPISENSORRANGEREADINGEVENTSENSOR:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorRangeReadingEventSensor,
                                 context->
                                 saHpiSensorRangeReadingEventSensor_len);
        break;

    case COLUMN_SAHPISENSORTHRESHOLDDEFNISTHRESHOLD:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorThresholdDefnIsThreshold,

                                 sizeof(context->saHpiSensorThresholdDefnIsThreshold));
        break;

    case COLUMN_SAHPISENSORTHRESHOLDDEFNTHOLDCAPABILITIES:

        snmp_set_var_typed_value(var, ASN_INTEGER,
                                 (char *) &context->
                                 saHpiSensorThresholdDefnTholdCapabilities,
                                 sizeof(context->
                                 saHpiSensorThresholdDefnTholdCapabilities));
        break;

    case COLUMN_SAHPISENSORTHRESHOLDDEFNREADTHOLD:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->
                                 saHpiSensorThresholdDefnReadThold,
                                 sizeof(context->
                                        saHpiSensorThresholdDefnReadThold));
        break;

    case COLUMN_SAHPISENSORTHRESHOLDDEFNWRITETHOLD:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->
                                 saHpiSensorThresholdDefnWriteThold,
                                 sizeof(context->
                                        saHpiSensorThresholdDefnWriteThold));
        break;

    case COLUMN_SAHPISENSORTHRESHOLDDEFNFIXEDTHOLD:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->
                                 saHpiSensorThresholdDefnFixedThold,
                                 sizeof(context->
                                        saHpiSensorThresholdDefnFixedThold));
        break;

    case COLUMN_SAHPISENSORTHRESHOLDRAW:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorThresholdRaw,
                                 context->saHpiSensorThresholdRaw_len);
        break;

    case COLUMN_SAHPISENSORTHRESHOLDINTERPRETED:
            /** OCTETSTR = ASN_OCTET_STR */
        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                 (char *) &context->
                                 saHpiSensorThresholdInterpreted,
                                 context->
                                 saHpiSensorThresholdInterpreted_len);
        break;

    case COLUMN_SAHPISENSOROEM:
            /** UNSIGNED32 = ASN_UNSIGNED */
        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                 (char *) &context->saHpiSensorOEM,
                                 sizeof(context->saHpiSensorOEM));
        break;

    case COLUMN_SAHPISENSORRDR:
            /** RowPointer = ASN_OBJECT_ID */
        snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                 (char *) &context->saHpiSensorRDR,
                                 context->saHpiSensorRDR_len);
        break;
    default:/** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                 "saHpiSensorTable_get_value\n");
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/************************************************************
 * saHpiSensorTable_get_by_idx
 */
/*
const saHpiSensorTable_context *
saHpiSensorTable_get_by_idx(netsnmp_index * hdr)
{
    return (const saHpiSensorTable_context *)
        CONTAINER_FIND(cb.container, hdr);
}
*/
