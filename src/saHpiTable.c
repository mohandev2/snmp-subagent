/*
 * (C) Copyright IBM Corp. 2003
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Authors:
 *   Konrad Rzeszutek <konradr@us.ibm.com>
 *
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id$ 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>

#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_assert.h>
#include <net-snmp/library/check_varbind.h>
#include <SaHpi.h>
#include <hpiSubagent.h>


#include <saHpiTable.h>
#include <saHpiRdrTable.h>
#include <saHpiEventTable.h>
#include <saHpiSystemEventLogTable.h>
#include <saHpiHotSwapTable.h>

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;

extern int send_traps;
extern u_long rpt_new_entry_count;
extern u_long rdr_new_entry_count;
extern u_long sel_new_entry_count;

static u_long entry_count = 0;
static u_long update_entry_count = -1;
static integer64 update_timestamp;

oid saHpiTable_oid[] = { saHpiTable_TABLE_OID };
size_t saHpiTable_oid_len = OID_LENGTH (saHpiTable_oid);
static oid saHpiEntryUpdateTimestamp_oid[] =
  { hpiEntity_OID, SCALAR_COLUMN_SAHPIENTRYUPDATETIMESTAMP, 0 };
static oid saHpiEntryUpdateCount_oid[] =
  { hpiEntity_OID, SCALAR_COLUMN_SAHPIENTRYUPDATECOUNT, 0 };
static oid saHpiEntryCount_oid[] =
  { hpiEntity_OID, SCALAR_COLUMN_SAHPIENTRYCOUNT, 0 };

static oid saHpiResourceNotification_oid[] = { hpiNotifications_OID, 6, 0 };

#define RPT_NOTIF_COUNT 4
#define RPT_NOTIF_ENTRY_ID 0
#define RPT_NOTIF_ENTITY_PATH 1
#define RPT_NOTIF_CAPABILITIES 2
#define RPT_NOTIF_SEVERITY 3

static trap_vars saHpiResourceNotification[] = {
  {COLUMN_SAHPIENTRYID, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIRESOURCEENTITYPATH, ASN_OCTET_STR, NULL, 0},
  {COLUMN_SAHPIRESOURCECAPABILITIES, ASN_UNSIGNED, NULL, 0},
  {COLUMN_SAHPIRESOURCESEVERITY, ASN_INTEGER, NULL, 0}
};

static unsigned int rpt_mutex = AGENT_FALSE;

static int
saHpiTable_modify_context (SaHpiRptEntryT * entry,
			   saHpiTable_context * ctx,
			   SaHpiTimeT * time,
			   SaHpiBoolT * state,
			   trap_vars ** var,
			   size_t * var_len, oid ** var_oid);


/*
 * Populates FOUR different rows:
 *  - RPT
 *  - RDR (by calling 'populate_rdr()'
 *  - HotSwap (by calling 'populate_hotswap()'
 *  - SEL (by calling 'populate_sel()')
 */
int
populate_rpt ()
{

  SaErrorT err = SA_OK;
  //SaHpiVersionT     version;
  SaHpiSessionIdT session;
  SaHpiRptEntryT rpt_entry;
  SaHpiRptInfoT rpt_info;
  SaHpiEntryIdT next = SAHPI_FIRST_ENTRY;
  SaHpiEntryIdT current = SAHPI_FIRST_ENTRY;
  SaHpiTimeT time;
  SaHpiBoolT state;

  int rc;
  long backup_count = entry_count;

  oid rpt_oid[RPT_INDEX_NR];
  oid DomainID_oid[MAX_OID_LEN];
  oid ResourceID_oid[MAX_OID_LEN];
  oid column[2];
  //   int                  column_len = 2;
  size_t DomainID_oid_len;
  size_t ResourceID_oid_len;



  netsnmp_index rpt_index;
  saHpiTable_context *rpt_context;

  // Events:
  oid *trap_oid;
  trap_vars *trap = NULL;
  size_t trap_len;
  netsnmp_variable_list *trap_var;

  DEBUGMSGTL ((AGENT, "--- populate_rpt: Entry.\n"));
  rpt_new_entry_count = 0;
  rdr_new_entry_count = 0;
  sel_new_entry_count = 0;
  if (getSaHpiSession (&session) == AGENT_ERR_NOERROR)
    {

      // Check to see if there are any new entries.

      err = didSaHpiChanged (&rpt_mutex, &rpt_info);

      if (rpt_mutex == AGENT_TRUE)
	{

	  // IBM-KR: Endian       
	  update_timestamp.low = rpt_info.UpdateTimestamp & 0xffffffff;
	  update_timestamp.high = rpt_info.UpdateTimestamp >> 32;

	  update_entry_count = rpt_info.UpdateCount;
	  // Yes, something new.
	  next = SAHPI_FIRST_ENTRY;
	  rpt_index.len = RPT_INDEX_NR;
	  do
	    {
	      memset (&rpt_entry, 0x0, sizeof (SaHpiRptEntryT));
	      current = next;

	      err = saHpiRptEntryGet (session, current, &next, &rpt_entry);
	      DEBUGMSGTL ((AGENT, "Current: %d, Next: %d\n", current, next));
	      if (SA_OK == err)
		{
		  DEBUGMSGTL ((AGENT, "ResourceID: %d, EntryId: %d\n",
			       rpt_entry.ResourceId, rpt_entry.EntryId));
		  // Get more information
		  err = saHpiEventLogTimeGet (session,
					      rpt_entry.ResourceId, &time);
		  err = SA_OK;
		  state = SAHPI_FALSE;
		  if (rpt_entry.ResourceCapabilities & SAHPI_CAPABILITY_SEL)
		  {
		    err = saHpiEventLogStateGet (session,
					       rpt_entry.ResourceId, &state);
		    
		    // IBM-KR: What's the right option? Set it to 'unknown' perhaps?
		    if (err != SA_OK)
		      {
			DEBUGMSGTL ((AGENT,
				     "Call to saHpiEventLogStateGet failed with rc: %s.\n",
				     get_error_string (err)));
			state = SAHPI_TRUE;
		      }
		    err = SA_OK;
		  }
		  // Construct the index from the entry. Look in the MIB for new index values
		  // Comment #020 changed the index order.
		  rpt_oid[0] = rpt_entry.DomainId;
		  rpt_oid[1] = rpt_entry.ResourceId;
		  rpt_oid[2] = rpt_entry.EntryId;

		  rpt_index.oids = (oid *) & rpt_oid;
		  if (backup_count == 0)
		    {
		      // First time (entry_count is updated when this loop is finished)
		      rpt_context = saHpiTable_create_row (&rpt_index);
		      rpt_new_entry_count ++;
		    }
		  else
		    {
		      // We are re-populating. Check for existing entries.
		      // See if it exists.
		      rpt_context = NULL;
		      rpt_context = CONTAINER_FIND (cb.container, &rpt_index);
		      // If we don't find it - we create it.

		      if (!rpt_context)
			{
			  // New entry. Add it
			  rpt_context = saHpiTable_create_row (&rpt_index);
		          rpt_new_entry_count ++;
			}
		      if (!rpt_context)
			{
			  snmp_log (LOG_ERR,
				    "Not enough memory for a RPT row!");
			  return AGENT_ERR_INTERNAL_ERROR;
			}
		    }

		  // Generate our full OID for the DomainID
		  column[0] = 1;
		  // Point to first object.
		  column[1] = COLUMN_SAHPIDOMAINID;

		  build_full_oid (saHpiTable_oid, saHpiTable_oid_len,
				  column, 2,
				  &rpt_index,
				  DomainID_oid, MAX_OID_LEN,
				  &DomainID_oid_len);

		  column[1] = COLUMN_SAHPIRESOURCEID;

		  build_full_oid (saHpiTable_oid, saHpiTable_oid_len,
				  column, 2,
				  &rpt_index,
				  ResourceID_oid, MAX_OID_LEN,
				  &ResourceID_oid_len);

		  // Mark this row as clean.
		  DEBUGMSGTL ((AGENT, "RPT (%d, %d, %d) entry cleaned.\n",
			       rpt_entry.DomainId,
			       rpt_entry.ResourceId, rpt_entry.EntryId));

		  rpt_context->dirty_bit = AGENT_FALSE;

		  // By this stage, rpt_context surely has something in it.
		  // '<table>_modify_context(..)' does a checksum check to see if 
		  // the record needs to be altered.

		  if (saHpiTable_modify_context (&rpt_entry,
						 rpt_context,
						 &time,
						 &state,
						 &trap, &trap_len, &trap_oid)
		      == AGENT_NEW_ENTRY)
		    {

		      CONTAINER_INSERT (cb.container, rpt_context);

		      entry_count = CONTAINER_SIZE (cb.container);

		      if (send_traps == AGENT_TRUE)
			{
			  if (trap != NULL)
			    {
			      trap_var = build_notification (&rpt_index,
							     trap, trap_len,
							     saHpiResourceNotification_oid,
							     OID_LENGTH
							     (saHpiResourceNotification_oid),
							     saHpiTable_oid,
							     saHpiTable_oid_len,
							     rpt_entry.
							     DomainId,
							     DomainID_oid,
							     DomainID_oid_len,
							     rpt_entry.
							     ResourceId,
							     ResourceID_oid,
							     ResourceID_oid_len);
			      if (trap_var != NULL)
				{
				  // Add two more entries: entryCount, and entryUpdate
				  snmp_varlist_add_variable (&trap_var,
							     saHpiEntryCount_oid,
							     OID_LENGTH
							     (saHpiEntryCount_oid),
							     ASN_COUNTER,
							     (u_char *) &
							     entry_count,
							     sizeof
							     (entry_count));
				  snmp_varlist_add_variable (&trap_var,
							     saHpiEntryUpdateCount_oid,
							     OID_LENGTH
							     (saHpiEntryUpdateCount_oid),
							     ASN_UNSIGNED,
							     (u_char *) &
							     update_entry_count,
							     sizeof
							     (update_entry_count));
				  DEBUGMSGTL ((AGENT,
					       "Sending the TRAP message\n"));
				  send_v2trap (trap_var);
				  snmp_free_varbind (trap_var);
				}
			      else
				{
				  snmp_log (LOG_WARNING,
					    "Could not build a RPT TRAP/EVENT message.\n");
				  rc = AGENT_ERR_BUILD_TRAP;
				}

			    }
			}
		    }



		  if (rpt_entry.ResourceCapabilities & SAHPI_CAPABILITY_RDR)
		    {
		      rc = populate_rdr (&rpt_entry,
					 DomainID_oid, DomainID_oid_len,
					 ResourceID_oid, ResourceID_oid_len);
		    }
		  // if (rpt... blah

		  if (rpt_entry.
		      ResourceCapabilities & SAHPI_CAPABILITY_MANAGED_HOTSWAP)
		    {

		      rc = populate_hotswap (&rpt_entry,
					     DomainID_oid, DomainID_oid_len);
		      //                       ResourceID_oid, ResourceID_oid_len);

		    }

		  // Reminder: The SEL are "historical" events that are
		  // ResourceID driven, not event-driven. Thus we populate them
		  // here.

		  // SEL and EVENTs (SEL corresponding Event information to be
		  // specific) MUST be the last to be populated. The reason 
		  // is b/c it calls entries in hotswap, rdr, and rpt rows - and
		  // if they don't exist before this populate_sel is called - 
		  // then the information (updating the HotSwap row with State and
		  // PreviousState) will be lost.

		  if ((rpt_entry.ResourceCapabilities & SAHPI_CAPABILITY_SEL)
		      || (rpt_entry.
			  ResourceCapabilities &
			  SAHPI_CAPABILITY_EVT_DEASSERTS)
		      || (rpt_entry.
			  ResourceCapabilities &
			  SAHPI_CAPABILITY_AGGREGATE_STATUS))
		    {
		      rc = populate_sel (&rpt_entry);
		      //DomainID_oid, DomainID_oid_len,
		      //        ResourceID_oid, ResourceID_oid_len);
		    }
		}		// rc != SA_OK
	      // Try next one ?
	      else
		{
		  DEBUGMSGTL ((AGENT, "saHpiRptEntryGet returned: %s\n",
			       get_error_string (err)));
		  next = SAHPI_LAST_ENTRY;
		  err = AGENT_ERR_OPERATION;
		}
	    }
	  while (next != SAHPI_LAST_ENTRY);

	  // Now check for deleted entries. 
	}			// if new_entries ...    

    }

  if (err == SA_OK)
    err = AGENT_ERR_NOERROR;

  if (rpt_new_entry_count > 0) 
  	snmp_log  (LOG_INFO,"Found %d RPT record%s.\n", rpt_new_entry_count,
		(rpt_new_entry_count > 1)? "s" : "");
  if (rdr_new_entry_count > 0)
  	snmp_log  (LOG_INFO,"Found %d RDR record%s.\n", rdr_new_entry_count,
		(rdr_new_entry_count > 1)? "s" : "");
  if (sel_new_entry_count > 0)
  	snmp_log  (LOG_INFO,"Found %d System Event Log record%s.\n", sel_new_entry_count,
		(sel_new_entry_count > 1)? "s" : "");

  DEBUGMSGTL ((AGENT, "--- populate_rpt: Exit.\n"));
  return err;
}

/*
 * Purges up to TWO rows:
 *  - RPT
 *  - HotSwap
 */
unsigned long
purge_rpt (void)
{

  SaHpiDomainIdT domain_id;
  SaHpiResourceIdT resource_id;
  SaHpiEntryIdT num;
  SaHpiCapabilitiesT capabilities;
  saHpiTable_context *rpt_context;
  int count = 0;
  unsigned int deleted;
  int rc;


  DEBUGMSGTL ((AGENT, "purge_rpt: Entry\n"));

  // Mutex. Only do the work when we have recently 
  // received fresh information.
  if (rpt_mutex == AGENT_TRUE)
    {

      rpt_context = CONTAINER_FIRST (cb.container);
      while (rpt_context != NULL)
	{

	  deleted = AGENT_FALSE;
	  DEBUGMSGTL ((AGENT, "Found %d.%d.%d purge: %s\n",
		       rpt_context->saHpiDomainID,
		       rpt_context->saHpiResourceID,
		       rpt_context->saHpiEntryID,
		       (rpt_context->dirty_bit ==
			AGENT_TRUE) ? "Yes" : "No"));

	  if (rpt_context != NULL)
	    {
	      if (rpt_context->dirty_bit == AGENT_FALSE)
		{
		  // Making it dirty again.
		  rpt_context->dirty_bit = AGENT_TRUE;
		}
	      else
		{
		  domain_id = rpt_context->saHpiDomainID;
		  resource_id = rpt_context->saHpiResourceID;
		  num = rpt_context->saHpiEntryID;
		  capabilities = rpt_context->saHpiResourceCapabilities;
		  // We are getting the next item here b/c effectivly the the rpt_context
		  // will be set to NULL in the 'delete_rpt_row' 
		  rpt_context = CONTAINER_NEXT (cb.container, rpt_context);
		  deleted = AGENT_TRUE;
		  count++;
		  // Delete the RPT row
		  rc = delete_rpt_row (domain_id, resource_id, num);
		  if (rc != AGENT_ERR_NOERROR)
		    DEBUGMSGTL ((AGENT,
				 "delete_rpt_row failed. return code: %d\n",
				 rc));


		  if (capabilities & SAHPI_CAPABILITY_MANAGED_HOTSWAP)
		    {
		      rc = delete_hotswap_row (domain_id, resource_id);
		      if (rc != AGENT_ERR_NOERROR)
			DEBUGMSGTL ((AGENT,
				     "delete_hotswap_row failed. Return code: %d\n",
				     rc));
		    }

		}
	    }
	  // Only get the next item if no deletion has happend.
	  if (deleted == AGENT_FALSE)
	    rpt_context = CONTAINER_NEXT (cb.container, rpt_context);

	}
      rpt_mutex = AGENT_FALSE;
    }
  DEBUGMSGTL ((AGENT, "purge_rpt. Exit (purged: %d).\n", count));
  return count;
}

int
saHpiTable_modify_context (SaHpiRptEntryT * entry,
			   saHpiTable_context * ctx,
			   SaHpiTimeT * time,
			   SaHpiBoolT * state,
			   trap_vars ** var,
			   size_t * var_len, oid ** var_trap_oid)
{

  unsigned int update_entry = MIB_FALSE;
  long hash;
  int len;
  // Make sure they are valid.

  if (entry && ctx)
    {

      // We are subtracting SaHpiTextBufferT b/c the underlaying HPI
      // library is not zeroing out the memory for not used entries -
      // thus garbage in SaHpiTextBufferT exist,
      hash = calculate_hash_value (entry, sizeof (SaHpiRptEntryT)
				   - sizeof (SaHpiTextBufferT));

      DEBUGMSGTL ((AGENT, " Hash value: %d, in ctx: %d\n", hash, ctx->hash));

      if (ctx->hash != 0)
	{
	  // Only do the check if the hash value is something else than zero.
	  // 'zero' value is only for newly created records, and in some
	  // rare instances when the hash has rolled to zero - in which
	  // case we will just consider the worst-case scenario and update
	  // the record and not trust the hash value.
	  if (hash == ctx->hash)
	    {
	      // The same data. No need to change.
	      return AGENT_ENTRY_EXIST;
	    }
	  if ((ctx->saHpiDomainID == entry->DomainId) &&
	      (ctx->saHpiResourceID == entry->ResourceId) &&
	      (ctx->saHpiEntryID == entry->EntryId)) {
		  update_entry = MIB_TRUE;
		  DEBUGMSGTL((AGENT,"Updating RPT entry [%d, %d, %d]\n",
				  entry->DomainId,
				  entry->ResourceId,
				  entry->EntryId));
	     }
	}

      if (hash == 0)
	hash = 1;
      ctx->hash = hash;

      ctx->saHpiResourceID = entry->ResourceId;
      ctx->saHpiDomainID = entry->DomainId;
      ctx->saHpiEntryID = entry->EntryId;

      len = entitypath2string (&entry->ResourceEntity,
			       ctx->saHpiResourceEntityPath,
			       SNMP_MAX_MSG_SIZE);
      if (len < 0)
	{
	  // Bummer, EntityPath too long to fit in the SNMP_MAX_MSG_SIZE.
	  len = 0;
	}
      DEBUGMSGTL ((AGENT, "EntityPath: %s\n", ctx->saHpiResourceEntityPath));
      ctx->saHpiResourceEntityPath_len = len;
      ctx->saHpiResourceCapabilities = entry->ResourceCapabilities;
      ctx->saHpiResourceSeverity = entry->ResourceSeverity + 1;
      ctx->saHpiResourceInfoResourceRev = entry->ResourceInfo.ResourceRev;
      ctx->saHpiResourceInfoSpecificVer = entry->ResourceInfo.SpecificVer;
      ctx->saHpiResourceInfoDeviceSupport = entry->ResourceInfo.DeviceSupport;
      ctx->saHpiResourceInfoManufacturerId =
	entry->ResourceInfo.ManufacturerId;
      ctx->saHpiResourceInfoProductId = entry->ResourceInfo.ProductId;
      ctx->saHpiResourceInfoFirmwareMajorRev =
	entry->ResourceInfo.FirmwareMajorRev;
      ctx->saHpiResourceInfoFirmwareMinorRev =
	entry->ResourceInfo.FirmwareMinorRev;
      ctx->saHpiResourceInfoAuxFirmwareRev =
	entry->ResourceInfo.AuxFirmwareRev;
      ctx->saHpiResourceTagTextType = entry->ResourceTag.DataType + 1;
      ctx->saHpiResourceTagTextLanguage = entry->ResourceTag.Language + 1;
      len = entry->ResourceTag.DataLength;
      //(entry->ResourceTag.DataLength > SAHPI_RESOURCE_TAG_MAX) ? 
      //SAHPI_RESOURCE_TAG_MAX : entry->ResourceTag.DataLength;
      strncpy (ctx->saHpiResourceTag, entry->ResourceTag.Data, len);
      ctx->saHpiResourceTag_len = len;

      // 'saHpiClearEvents' is controlled via 'update_event_status_flag'
      ctx->saHpiClearEvents = SNMP_ROW_NOTINSERVICE;
      ctx->saHpiParamControl = PARAM_UNDEFINED;

      // IBM-KR: Endian
      ctx->saHpiEventLogTime.low = *time & 0xffffffff;
      ctx->saHpiEventLogTime.high = *time >> 32;

      ctx->saHpiEventLogState = (*state == SAHPI_TRUE) ? MIB_TRUE : MIB_FALSE;

      // Fix the trap messages
      saHpiResourceNotification[RPT_NOTIF_ENTRY_ID].value =
	(u_char *) & ctx->saHpiEntryID;
      saHpiResourceNotification[RPT_NOTIF_ENTRY_ID].value_len =
	sizeof (ctx->saHpiEntryID);

      saHpiResourceNotification[RPT_NOTIF_ENTITY_PATH].value =
	(u_char *) & ctx->saHpiResourceEntityPath;
      saHpiResourceNotification[RPT_NOTIF_ENTITY_PATH].value_len =
	ctx->saHpiResourceEntityPath_len;

      saHpiResourceNotification[RPT_NOTIF_CAPABILITIES].value =
	(u_char *) & ctx->saHpiResourceCapabilities;
      saHpiResourceNotification[RPT_NOTIF_CAPABILITIES].value_len =
	sizeof (ctx->saHpiResourceCapabilities);

      saHpiResourceNotification[RPT_NOTIF_SEVERITY].value =
	(u_char *) & ctx->saHpiResourceSeverity;
      saHpiResourceNotification[RPT_NOTIF_SEVERITY].value_len =
	sizeof (ctx->saHpiResourceSeverity);

      // Point *var to this trap_vars. 
      *var = (trap_vars *) & saHpiResourceNotification;
      *var_len = RPT_NOTIF_COUNT;
      *var_trap_oid = (oid *) & saHpiResourceNotification_oid;

      if (update_entry == MIB_TRUE)
	      return AGENT_ENTRY_EXIST;
      return AGENT_NEW_ENTRY;
    }

  return AGENT_ERR_NULL_DATA;
}


int
set_logstate (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaErrorT rc;
  SaHpiBoolT enable;

  enable = (ctx->saHpiEventLogState == MIB_TRUE) ? SAHPI_TRUE : SAHPI_FALSE;

  if (ctx)
    {

      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  return rc;
	}
      DEBUGMSGTL ((AGENT, "Calling 'saHpiEventLogStateSet'  with %d\n",
		   enable));
      rc = saHpiEventLogStateSet (session_id, ctx->saHpiResourceID, enable);

      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Calling saHpiEventLogStateSet failed with return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "Error for 'saHpiEventLogStateSet' is %s\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;
}


int
set_table_tag (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaHpiTextBufferT tag;
  SaErrorT rc;

  if (ctx)
    {

      memset (&tag, 0x00, sizeof (SaHpiTextBufferT));
      tag.DataType = ctx->saHpiResourceTagTextType - 1;
      tag.Language = ctx->saHpiResourceTagTextLanguage - 1;
      tag.DataLength = ctx->saHpiResourceTag_len;

      memcpy (tag.Data, ctx->saHpiResourceTag, ctx->saHpiResourceTag_len);

      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	return rc;


      rc = saHpiResourceTagSet (session_id, ctx->saHpiResourceID, &tag);

      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Calling saHpiResourceTagSet failed with return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "Call to 'saHpiResourceTagSet'; rc: %s\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;

}



int
set_event_log_time (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaErrorT rc;
  SaHpiTimeT time;
  if (ctx)
    {
      //IBM-KR: Endian

      time = ctx->saHpiEventLogTime.high;
      time = time << 32;
      time += ctx->saHpiEventLogTime.low;

      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		       rc));
	  return rc;
	}
      rc = saHpiEventLogTimeSet (session_id, ctx->saHpiResourceID, time);

      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Call to saHpiEventLogTimeSet failed with return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT,
		       "Call to 'saHpiEventLogTimeSet' failed with rc: %s\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;

}

int
set_clear_events (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaErrorT rc;

  if (ctx)
    {


      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		       rc));
	  return rc;
	}

      rc = saHpiEventLogClear (session_id, ctx->saHpiResourceID);


      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Call to saHpiEventLogClear failed with return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "Call to 'saHpiEventLogClear' rc: %s\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;

}

int
set_table_param_control (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaHpiParmActionT action;
  SaErrorT rc;

  if (ctx)
    {

      action = ctx->saHpiParamControl-1;

      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		       rc));
	  return rc;
	}
      rc = saHpiParmControl (session_id, ctx->saHpiResourceID, action);

      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Call to saHpiParamControl failed, return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "Call to saHpiParmControl rc: %s\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;

}

int
delete_rpt_row (SaHpiDomainIdT domain_id,
		SaHpiResourceIdT resource_id, SaHpiEntryIdT num)
{

  saHpiTable_context *ctx;
  oid rpt_oid[RPT_INDEX_NR];
  netsnmp_index rpt_index;
  int rc = AGENT_ERR_NOT_FOUND;

  DEBUGMSGTL ((AGENT, "delete_rpt_row (%d, %d, %d). Entry\n",
	       domain_id, resource_id, num));

  rpt_oid[0] = domain_id;
  rpt_oid[1] = resource_id;
  rpt_oid[2] = num;

  // Possible more indexs?
  rpt_index.oids = (oid *) & rpt_oid;
  rpt_index.len = RPT_INDEX_NR;

  ctx = CONTAINER_FIND (cb.container, &rpt_index);

  if (ctx)
    {
      CONTAINER_REMOVE (cb.container, ctx);
      saHpiTable_delete_row (ctx);
      entry_count = CONTAINER_SIZE (cb.container);
      rc = AGENT_ERR_NOERROR;
    }
  DEBUGMSGTL ((AGENT, "delete_rpt_row. Exit (rc: %d).\n", rc));
  return rc;
}


int
update_event_status_flag (SaHpiDomainIdT domain_id,
			  SaHpiResourceIdT resource_id, long event_status)
{

  saHpiTable_context *ctx;
  oid rpt_oid[RPT_INDEX_NR - 1];
  netsnmp_index rpt_index;
  netsnmp_void_array *array;
  int rc = AGENT_ERR_NOT_FOUND;
  unsigned long i = 0;

  DEBUGMSGTL ((AGENT, "Entry: update_event_status_flag (%d, %d, %d).\n",
	       domain_id, resource_id, event_status));

  rpt_oid[0] = domain_id;
  rpt_oid[1] = resource_id;

  // Possible more indexs?
  rpt_index.oids = (oid *) & rpt_oid;
  rpt_index.len = RPT_INDEX_NR - 1;
  array = (netsnmp_void_array *) CONTAINER_GET_SUBSET (cb.container, &rpt_index);
  if (array != NULL)
    {
      if (array->size > 0)
	{
	  for (i = 0; i < array->size; i++)
	    {
	      ctx = array->array[i];
	      ctx->saHpiClearEvents = event_status;
	    }
	  rc = AGENT_ERR_NOERROR;
	}
      free(array->array);
      free(array); array = NULL;
    }
  DEBUGMSGTL ((AGENT, "Exit: update_event_status_flag (rc: %d, updated: %d).\n",
	       rc, i));
  return rc;
}

int
set_table_severity (saHpiTable_context * ctx)
{

  SaHpiSessionIdT session_id;
  SaHpiSeverityT severity;
  SaErrorT rc;

  if (ctx)
    {

      severity = ctx->saHpiResourceSeverity - 1;
      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		       rc));
	  return rc;
	}
      rc = saHpiResourceSeveritySet (session_id,
				     ctx->saHpiResourceID, severity);

      if (rc != SA_OK)
	{
	  snmp_log (LOG_ERR,
		    "Call to saHpiResourceSeverity failed with return code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT,
		       "Call to saHpiResourceSeveritySet failed with rc: %s.\n",
		       get_error_string (rc)));
	  return AGENT_ERR_OPERATION;
	}

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;
}


/************************************************************
 * the *_row_copy routine
 */

static int
saHpiTable_row_copy (saHpiTable_context * dst, saHpiTable_context * src)
{

  if (!dst || !src)
    return 1;


  if (dst->index.oids)
    free (dst->index.oids);
  if (snmp_clone_mem ((void *) &dst->index.oids, src->index.oids,
		      src->index.len * sizeof (oid)))
    {
      dst->index.oids = NULL;
      return 1;
    }
  dst->index.len = src->index.len;

  dst->saHpiDomainID = src->saHpiDomainID;

  dst->saHpiEntryID = src->saHpiEntryID;

  dst->saHpiResourceID = src->saHpiResourceID;

  memcpy (dst->saHpiResourceEntityPath, src->saHpiResourceEntityPath,
	  src->saHpiResourceEntityPath_len);
  dst->saHpiResourceEntityPath_len = src->saHpiResourceEntityPath_len;

  dst->saHpiResourceCapabilities = src->saHpiResourceCapabilities;

  dst->saHpiResourceSeverity = src->saHpiResourceSeverity;

  dst->saHpiResourceInfoResourceRev = src->saHpiResourceInfoResourceRev;

  dst->saHpiResourceInfoSpecificVer = src->saHpiResourceInfoSpecificVer;

  dst->saHpiResourceInfoDeviceSupport = src->saHpiResourceInfoDeviceSupport;

  dst->saHpiResourceInfoManufacturerId = src->saHpiResourceInfoManufacturerId;

  dst->saHpiResourceInfoProductId = src->saHpiResourceInfoProductId;

  dst->saHpiResourceInfoFirmwareMajorRev =
    src->saHpiResourceInfoFirmwareMajorRev;

  dst->saHpiResourceInfoFirmwareMinorRev =
    src->saHpiResourceInfoFirmwareMinorRev;

  dst->saHpiResourceInfoAuxFirmwareRev = src->saHpiResourceInfoAuxFirmwareRev;

  dst->saHpiResourceTagTextType = src->saHpiResourceTagTextType;

  dst->saHpiResourceTagTextLanguage = src->saHpiResourceTagTextLanguage;

  memcpy (dst->saHpiResourceTag, src->saHpiResourceTag,
	  src->saHpiResourceTag_len);
  dst->saHpiResourceTag_len = src->saHpiResourceTag_len;

  dst->saHpiParamControl = src->saHpiParamControl;

  dst->saHpiClearEvents = src->saHpiClearEvents;

  memcpy (&dst->saHpiEventLogTime, &src->saHpiEventLogTime,
	  sizeof (integer64));

  dst->hash = src->hash;
  dst->dirty_bit = src->dirty_bit;


  return 0;
}


/*
 * the *_extract_index routine
 */
int
saHpiTable_extract_index (saHpiTable_context * ctx, netsnmp_index * hdr)
{
  /*
   * temporary local storage for extracting oid index
   */
  netsnmp_variable_list var_saHpiDomainID;
  netsnmp_variable_list var_saHpiEntryID;
  netsnmp_variable_list var_saHpiResourceID;
  int err;


  /*
   * copy index, if provided
   */
  if (hdr)
    {
      netsnmp_assert (ctx->index.oids == NULL);
      if (snmp_clone_mem ((void *) &ctx->index.oids, hdr->oids,
			  hdr->len * sizeof (oid)))
	{
	  return -1;
	}
      ctx->index.len = hdr->len;
    }

    /**
     * Create variable to hold each component of the index
     */

  // Order changed per #020 comment.
  memset (&var_saHpiDomainID, 0x00, sizeof (var_saHpiDomainID));
  var_saHpiDomainID.type = ASN_UNSIGNED;
  var_saHpiDomainID.next_variable = &var_saHpiResourceID;

  memset (&var_saHpiResourceID, 0x00, sizeof (var_saHpiResourceID));
  var_saHpiResourceID.type = ASN_UNSIGNED;
  var_saHpiResourceID.next_variable = &var_saHpiEntryID;

  memset (&var_saHpiEntryID, 0x00, sizeof (var_saHpiEntryID));
  var_saHpiEntryID.type = ASN_UNSIGNED;
  var_saHpiEntryID.next_variable = NULL;

  err = parse_oid_indexes (hdr->oids, hdr->len, &var_saHpiDomainID);

  if (err == SNMP_ERR_NOERROR)
    {
      /*
       * copy components into the context structure
       */
      ctx->saHpiDomainID = *var_saHpiDomainID.val.integer;

      ctx->saHpiEntryID = *var_saHpiEntryID.val.integer;

      ctx->saHpiResourceID = *var_saHpiResourceID.val.integer;

      // if ( *var_saHpiEntryID.val.integer != SAHPI_LAST_ENTRY ) {
      //    DEBUGMSGTL((AGENT, "saHpiEntryID == SAHPI_LAST_ENTRY "));
      //            err = -1;
      // }
      // if ( *var_saHpiEntryID.val.integer !=  SAHPI_FIRST_ENTRY) {
      //     DEBUGMSGTL((AGENT, "saHpiEntryID == SAHPI_FIRST_ENTRY "));
      //             err = -1;
      // }

    }

  /*
   * parsing may have allocated memory. free it.
   */
  snmp_reset_var_buffers (&var_saHpiDomainID);

  return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int
saHpiTable_can_delete (saHpiTable_context * undo_ctx,
		       saHpiTable_context * row_ctx,
		       netsnmp_request_group * rg)
{

  return 1;
}

/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated saHpiTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
saHpiTable_context *
saHpiTable_create_row (netsnmp_index * hdr)
{

  saHpiTable_context *ctx = SNMP_MALLOC_TYPEDEF (saHpiTable_context);
  if (!ctx)
    return NULL;

  if (saHpiTable_extract_index (ctx, hdr))
    {
      free (ctx->index.oids);
      free (ctx);
      return NULL;
    }

  ctx->hash = 0;
  ctx->saHpiResourceSeverity = 0;
  ctx->saHpiResourceTagTextType = 0;
  ctx->saHpiResourceTagTextLanguage = 0;
  ctx->saHpiResourceTag_len = 0;
  ctx->saHpiParamControl = 0;
  ctx->saHpiClearEvents = SNMP_ROW_NOTINSERVICE;

  ctx->saHpiEventLogTime.low = 0;
  ctx->saHpiEventLogTime.high = 0;

  ctx->dirty_bit = AGENT_TRUE;
  return ctx;
}

/************************************************************
 * the *_duplicate row routine
 */
saHpiTable_context *
saHpiTable_duplicate_row (saHpiTable_context * row_ctx)
{

  saHpiTable_context *dup;

  if (!row_ctx)
    return NULL;

  dup = SNMP_MALLOC_TYPEDEF (saHpiTable_context);
  if (!dup)
    return NULL;

  if (saHpiTable_row_copy (dup, row_ctx))
    {
      free (dup);
      dup = NULL;
    }

  return dup;

}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index *
saHpiTable_delete_row (saHpiTable_context * ctx)
{

  if (ctx->index.oids)
    free (ctx->index.oids);

  /*
   * release header
   */
  free (ctx);

  return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void
saHpiTable_set_reserve1 (netsnmp_request_group * rg)
{
  saHpiTable_context *row_ctx = (saHpiTable_context *) rg->existing_row;

  netsnmp_variable_list *var;
  netsnmp_request_group_item *current;
  int rc = SNMP_ERR_NOERROR;

  DEBUGMSGTL ((AGENT, "saHpiTable_set_reserve1. Entry.\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIRESOURCESEVERITY:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiResourceSeverity));
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiResourceTagTextType));
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiResourceTagTextLanguage));
	  break;

	case COLUMN_SAHPIRESOURCETAG:
	    /** OCTETSTR = ASN_OCTET_STR */
	  if (var->type != ASN_OCTET_STR)
	    {
	      rc = SNMP_ERR_WRONGTYPE;
	    }
	  else if (var->val_len > SAHPI_RESOURCE_TAG_MAX)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  else if (var->val_len < 0)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  break;
	case COLUMN_SAHPIDOMAINID:
	case COLUMN_SAHPIENTRYID:
	case COLUMN_SAHPIRESOURCEID:
	case COLUMN_SAHPIRESOURCEENTITYPATH:
	case COLUMN_SAHPIRESOURCECAPABILITIES:
	case COLUMN_SAHPIRESOURCEINFORESOURCEREV:
	case COLUMN_SAHPIRESOURCEINFOSPECIFICVER:
	case COLUMN_SAHPIRESOURCEINFODEVICESUPPORT:
	case COLUMN_SAHPIRESOURCEINFOMANUFACTURERID:
	case COLUMN_SAHPIRESOURCEINFOPRODUCTID:
	case COLUMN_SAHPIRESOURCEINFOFIRMWAREMAJORREV:
	case COLUMN_SAHPIRESOURCEINFOFIRMWAREMINORREV:
	case COLUMN_SAHPIRESOURCEINFOAUXFIRMWAREREV:
	  rc = SNMP_ERR_NOTWRITABLE;
	  break;
	case COLUMN_SAHPIPARAMCONTROL:
		 /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiParamControl));
	  break;

	case COLUMN_SAHPICLEAREVENTS:
	    /** RowStatus = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiClearEvents));
	  break;

	case COLUMN_SAHPIEVENTLOGTIME:
	    /** HpiTimeStamp = ASN_COUNTER64 */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_COUNTER64,
					       sizeof (row_ctx->
						       saHpiEventLogTime));

	  break;
	case COLUMN_SAHPIEVENTLOGSTATE:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiEventLogState));
	  break;
	default:
		/** We shouldn't get here */
	  rc = SNMP_ERR_GENERR;
	  snmp_log (LOG_ERR, "unknown column in "
		    "saHpiTable_set_reserve1\n");
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
      rg->status = SNMP_MAX (rg->status, current->ri->status);
    }

  for (current = rg->list; current; current = current->next)
    {

      if (row_ctx->hash == 0)
	{
	  // The row doesn't exist.
	  //rc =  SNMP_ERR_NOSUCHNAME;
	  var = current->ri->requestvb;

	  // SNMPv2-TC has a diagram of actions for non-existing rows.
	  if ((*var->val.integer == SNMP_ROW_CREATEANDGO)	// createAndGo(4)
	      || (*var->val.integer == SNMP_ROW_ACTIVE)	// active (1)
	      || (*var->val.integer == SNMP_ROW_NOTINSERVICE))	// notInService(2)
	    rc = SNMP_ERR_INCONSISTENTVALUE;
	  if (*var->val.integer == SNMP_ROW_NOTREADY)	// notReady(3)
	    rc = SNMP_ERR_INCONSISTENTNAME;
	  if (*var->val.integer == SNMP_ROW_CREATEANDWAIT)	// createAndWait(5)
	    rc = SNMP_ERR_WRONGVALUE;

	  //if (*var->val.integer == SNMP_ROW_DESTROY) // destory(6)
	  // rc = SNMP_ERR_INCONSISTENTNAME;

	  if (rc)
	    netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
	}
    }
  DEBUGMSGTL ((AGENT, "saHpiTable_set_reserve1. Exit.\n"));
}

void
saHpiTable_set_reserve2 (netsnmp_request_group * rg)
{

  netsnmp_request_group_item *current;
  netsnmp_variable_list *var;
  int rc;

  rg->rg_void = rg->list->ri;
  DEBUGMSGTL ((AGENT, "saHpiTable_set_reserve2. Entry.\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIRESOURCESEVERITY:
	  if (((*var->val.integer < 1) ||
	       (*var->val.integer > 5)) && (*var->val.integer != 81))
	    {
	      rc = SNMP_ERR_BADVALUE;
	    }
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTTYPE:
	  // Not include undefined(0) since its non-compliant.
	  if (((*var->val.integer < 1) || (*var->val.integer > 4)))
	    {
	      rc = SNMP_ERR_BADVALUE;
	    }
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTLANGUAGE:
	  if (((*var->val.integer < 1) || (*var->val.integer > 137)))
	    {
	      rc = SNMP_ERR_BADVALUE;
	    }
	  break;

	case COLUMN_SAHPIRESOURCETAG:
	  break;

	case COLUMN_SAHPIPARAMCONTROL:
	  if (((*var->val.integer < 1) || (*var->val.integer > 3)))
	    {
	      rc = SNMP_ERR_BADVALUE;
	    }
	  break;

	case COLUMN_SAHPICLEAREVENTS:
	  // This can only be destroy(6)
	  if (*var->val.integer != SNMP_ROW_DESTROY)
	    rc = SNMP_ERR_BADVALUE;
	  break;

	case COLUMN_SAHPIEVENTLOGTIME:
	  break;

	case COLUMN_SAHPIEVENTLOGSTATE:
	  if ((*var->val.integer < 1) || (*var->val.integer > 2))
	    {
	      rc = SNMP_ERR_BADVALUE;
	    }
	  break;
	default:
		/** We shouldn't get here */
	  netsnmp_assert (0);  /** why wasn't this caught in reserve1? */
	  break;
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
    }
  DEBUGMSGTL ((AGENT, "saHpiTable_set_reserve2. Exit.\n"));
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void
saHpiTable_set_action (netsnmp_request_group * rg)
{
  netsnmp_variable_list *var;
  saHpiTable_context *row_ctx = (saHpiTable_context *) rg->existing_row;
  netsnmp_request_group_item *current;

  int rc = SNMP_ERR_NOERROR;


  DEBUGMSGTL ((AGENT, "saHpiTable_set_action. Entry.\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIRESOURCESEVERITY:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiResourceSeverity = *var->val.integer;
	  if (set_table_severity (row_ctx) != AGENT_ERR_NOERROR)
	    rc = SNMP_ERR_GENERR;
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiResourceTagTextType = *var->val.integer;
	  break;

	case COLUMN_SAHPIRESOURCETAGTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiResourceTagTextLanguage = *var->val.integer;
	  break;

	case COLUMN_SAHPIRESOURCETAG:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiResourceTag, var->val.string, var->val_len);
	  row_ctx->saHpiResourceTag_len = var->val_len;
	  if (set_table_tag (row_ctx) != AGENT_ERR_NOERROR)
	    rc = SNMP_ERR_GENERR;
	  break;

	case COLUMN_SAHPIPARAMCONTROL:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiParamControl = *var->val.integer;
	  if (set_table_param_control (row_ctx) != AGENT_ERR_NOERROR)
	    rc = SNMP_ERR_GENERR;
	  break;

	case COLUMN_SAHPICLEAREVENTS:
	    /** RowStatus = ASN_INTEGER */
	  row_ctx->saHpiClearEvents = SNMP_ROW_NOTINSERVICE;
	  // If the row doesn't have the hash value, its our internal ones,
	  // and we will discard it.
	  if (row_ctx->hash == 0)
	    rg->row_deleted = 1;
	  else
	    {
	      // For rows that exist, try to clear the events 
	      if (set_clear_events (row_ctx) != AGENT_ERR_NOERROR)
		{
		  rc = SNMP_ERR_GENERR;
		}
	      else
		{		// and if it succeded, clear the SEL rows.
		  // Success. Now its time to remove the events and SEL entries.
		  if (delete_SEL_row (row_ctx->saHpiDomainID,
				      row_ctx->saHpiResourceID) !=
		      AGENT_ERR_NOERROR)
		    {
		      rc = SNMP_ERR_GENERR;
		    }
		}
	    }

	  break;

	case COLUMN_SAHPIEVENTLOGTIME:
	    /** HpiTimeStamp = ASN_COUNTER64 */
	  row_ctx->saHpiEventLogTime = *var->val.counter64;

	  if (set_event_log_time (row_ctx) != AGENT_ERR_NOERROR)
	    rc = SNMP_ERR_GENERR;
	  break;
	case COLUMN_SAHPIEVENTLOGSTATE:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiEventLogState = *var->val.integer;
	  if (set_logstate (row_ctx) != AGENT_ERR_NOERROR)
	    {
	      rc = SNMP_ERR_GENERR;
	    }
	  else
	    {
	      // IBM-KR:  Send event?
	    }
	  break;

	default:
		/** We shouldn't get here */
	  netsnmp_assert (0);  /** why wasn't this caught in reserve1? */
	  break;
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);

    }
  DEBUGMSGTL ((AGENT, "saHpiTable_set_action. Exit (rc: %d).\n", rc));
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void
saHpiTable_set_commit (netsnmp_request_group * rg)
{


}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void
saHpiTable_set_free (netsnmp_request_group * rg)
{

}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void
saHpiTable_set_undo (netsnmp_request_group * rg)
{


}



/************************************************************
 *
 * Initialize the saHpiTable table by defining its contents and how it's structured
 */
void
initialize_table_saHpiTable (void)
{
  netsnmp_table_registration_info *table_info;

  if (my_handler)
    {
      snmp_log (LOG_ERR,
		"initialize_table_saHpiTable_handler called again\n");
      return;
    }

  memset (&cb, 0x00, sizeof (cb));

    /** create the table structure itself */
  table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);

  /*
   * if your table is read only, it's easiest to change the
   * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
   */
  my_handler = netsnmp_create_handler_registration ("saHpiTable",
						    netsnmp_table_array_helper_handler,
						    saHpiTable_oid,
						    saHpiTable_oid_len,
						    HANDLER_CAN_RWRITE);

  if (!my_handler || !table_info)
    {
      snmp_log (LOG_ERR, "malloc failed in "
		"initialize_table_saHpiTable_handler\n");
      return;	/** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */

  /*
   * internal indexes
   */
	/** index: saHpiDomainID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
      /** index: saHpiResourceID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
	/** index: saHpiEntryID */
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);


  table_info->min_column = saHpiTable_COL_MIN;
  table_info->max_column = saHpiTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
  cb.get_value = saHpiTable_get_value;
  cb.container = netsnmp_container_find ("saHpiTable_primary:"
					 "saHpiTable:" "table_container");

  cb.create_row = (UserRowMethod *) saHpiTable_create_row;

  cb.can_set = 0;
  cb.duplicate_row = (UserRowMethod *) saHpiTable_duplicate_row;

  cb.delete_row = (UserRowMethod *) saHpiTable_delete_row;

  cb.row_copy = (Netsnmp_User_Row_Operation *) saHpiTable_row_copy;

  cb.can_delete = (Netsnmp_User_Row_Action *) saHpiTable_can_delete;

  cb.set_reserve1 = saHpiTable_set_reserve1;
  cb.set_reserve2 = saHpiTable_set_reserve2;
  cb.set_action = saHpiTable_set_action;
  cb.set_commit = saHpiTable_set_commit;
  cb.set_free = saHpiTable_set_free;
  cb.set_undo = saHpiTable_set_undo;

  DEBUGMSGTL (("initialize_table_saHpiTable",
	       "Registering table saHpiTable " "as a table array\n"));
  netsnmp_table_container_register (my_handler, table_info, &cb,
				    cb.container, 1);

  // Register int 

  netsnmp_register_read_only_counter32_instance ("entry_count",
						 saHpiEntryCount_oid,
						 OID_LENGTH
						 (saHpiEntryCount_oid),
						 &entry_count, NULL);
  netsnmp_register_read_only_ulong_instance ("update_count",
					     saHpiEntryUpdateCount_oid,
					     OID_LENGTH
					     (saHpiEntryUpdateCount_oid),
					     &update_entry_count, NULL);
  netsnmp_register_read_only_instance (netsnmp_create_handler_registration
				       ("update_timestamp",
					update_timestamp_handler,
					saHpiEntryUpdateTimestamp_oid,
					OID_LENGTH
					(saHpiEntryUpdateTimestamp_oid),
					HANDLER_CAN_RONLY));


}

/************************************************************
 * saHpiTable_get_value
 */
int
saHpiTable_get_value (netsnmp_request_info * request,
		      netsnmp_index * item,
		      netsnmp_table_request_info * table_info)
{
  DEBUGMSGTL ((AGENT, "--- saHpiTable_get_value: Entry\n"));
  netsnmp_variable_list *var = request->requestvb;
  saHpiTable_context *context = (saHpiTable_context *) item;

  switch (table_info->colnum)
    {

    case COLUMN_SAHPIDOMAINID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiDomainID,
				sizeof (context->saHpiDomainID));
      break;

    case COLUMN_SAHPIENTRYID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiEntryID,
				sizeof (context->saHpiEntryID));
      break;

    case COLUMN_SAHPIRESOURCEID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiResourceID,
				sizeof (context->saHpiResourceID));
      break;

    case COLUMN_SAHPIRESOURCEENTITYPATH:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiResourceEntityPath,
				context->saHpiResourceEntityPath_len);
      break;

    case COLUMN_SAHPIRESOURCECAPABILITIES:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceCapabilities,
				sizeof (context->saHpiResourceCapabilities));
      break;

    case COLUMN_SAHPIRESOURCESEVERITY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiResourceSeverity,
				sizeof (context->saHpiResourceSeverity));
      break;

    case COLUMN_SAHPIRESOURCEINFORESOURCEREV:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoResourceRev,
				sizeof (context->
					saHpiResourceInfoResourceRev));
      break;

    case COLUMN_SAHPIRESOURCEINFOSPECIFICVER:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoSpecificVer,
				sizeof (context->
					saHpiResourceInfoSpecificVer));
      break;

    case COLUMN_SAHPIRESOURCEINFODEVICESUPPORT:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoDeviceSupport,
				sizeof (context->
					saHpiResourceInfoDeviceSupport));
      break;

    case COLUMN_SAHPIRESOURCEINFOMANUFACTURERID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoManufacturerId,
				sizeof (context->
					saHpiResourceInfoManufacturerId));
      break;

    case COLUMN_SAHPIRESOURCEINFOPRODUCTID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoProductId,
				sizeof (context->saHpiResourceInfoProductId));
      break;

    case COLUMN_SAHPIRESOURCEINFOFIRMWAREMAJORREV:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoFirmwareMajorRev,
				sizeof (context->
					saHpiResourceInfoFirmwareMajorRev));
      break;

    case COLUMN_SAHPIRESOURCEINFOFIRMWAREMINORREV:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoFirmwareMinorRev,
				sizeof (context->
					saHpiResourceInfoFirmwareMinorRev));
      break;

    case COLUMN_SAHPIRESOURCEINFOAUXFIRMWAREREV:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->
				saHpiResourceInfoAuxFirmwareRev,
				sizeof (context->
					saHpiResourceInfoAuxFirmwareRev));
      break;

    case COLUMN_SAHPIRESOURCETAGTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiResourceTagTextType,
				sizeof (context->saHpiResourceTagTextType));
      break;

    case COLUMN_SAHPIRESOURCETAGTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiResourceTagTextLanguage,
				sizeof (context->
					saHpiResourceTagTextLanguage));
      break;

    case COLUMN_SAHPIRESOURCETAG:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->saHpiResourceTag,
				context->saHpiResourceTag_len);
      break;
    case COLUMN_SAHPIPARAMCONTROL:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiParamControl,
				sizeof (context->saHpiParamControl));
      break;

    case COLUMN_SAHPICLEAREVENTS:
	    /** RowStatus = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiClearEvents,
				sizeof (context->saHpiClearEvents));
      break;

    case COLUMN_SAHPIEVENTLOGTIME:
	    /** HpiTimeStamp = ASN_COUNTER64 */
      snmp_set_var_typed_value (var, ASN_COUNTER64,
				(char *) &context->saHpiEventLogTime,
				sizeof (context->saHpiEventLogTime));
      break;
    case COLUMN_SAHPIEVENTLOGSTATE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiEventLogState,
				sizeof (context->saHpiEventLogState));
      break;

    default:
	    /** We shouldn't get here */
      snmp_log (LOG_ERR, "unknown column in " "saHpiTable_get_value\n");
      return SNMP_ERR_GENERR;
    }
  DEBUGMSGTL ((AGENT, "--- saHpiTable_get_value: Exit\n"));
  return SNMP_ERR_NOERROR;
}


int
update_timestamp_handler (netsnmp_mib_handler * handler,
			  netsnmp_handler_registration * reginfo,
			  netsnmp_agent_request_info * reqinfo,
			  netsnmp_request_info * requests)
{



  if (reqinfo->mode == MODE_GET)
    snmp_set_var_typed_value (requests->requestvb, ASN_COUNTER64,
			      (u_char *) & update_timestamp,
			      sizeof (update_timestamp));

  return SNMP_ERR_NOERROR;
}
